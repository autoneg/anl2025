{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ANL 2025 Documentation","text":"<p>This repository is the official platform for running ANAC Automated Negotiation Leagues (starting 2025). It will contain a module called <code>anlXXXX</code> for the competition run in year XXXX. For example anl2025 will contain all files related to the 2025's version of the competition.</p> <p>This package is a thin-wrapper around the NegMAS library for automated negotiation. Its main goal is to provide the following functionalities:</p> <ol> <li>A method for generating scenarios to run tournaments in the same settings as in the ANL competition. These functions are always called <code>anl20XX_tournament</code> for year <code>20XX</code>.</li> <li>A CLI for running tournaments called <code>anl</code>.</li> </ol> <ol> <li>A place to hold the official implementation of every strategy submitted to the ANL competition after each year. These can be found in the module <code>anl.anl20XX.negotiators</code> for year <code>20XX</code>.</li> </ol> <p>The official website for the ANL competition is: https://scml.cs.brown.edu/anl</p>"},{"location":"#quick-start","title":"Quick start","text":"<pre><code>pip install anl2025\n</code></pre> <p>You can also install the in-development version with::</p> <pre><code>pip install git+https://github.com/autoneg/anl2025.git\n</code></pre>"},{"location":"#cli","title":"CLI","text":"<p>After installation, you can try running a tournament using the CLI:</p> <pre><code>anl tournament run --generate=5\n</code></pre> <p>To find all the parameters you can customize for running tournaments run:</p> <pre><code>anl tournament run --help\n</code></pre> <p>You can run the following command to check the versions of ANL and NegMAS on your machine:</p> <pre><code>anl2025 version\n</code></pre> <p>You should get at least these versions:</p> <pre><code>anl: 0.1.5 (NegMAS: 0.10.9)\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>Info</p> <p>This is not required to participate in the ANL competition</p> <p>If you would like to contribute to ANL, please clone the repo, then run:</p> <pre><code>python -m pip install -r requirements.txt\npython -m pip install -r requirements-dev.txt\npython -m pip install -r docs/requirements.txt\npython -m pip install -e .\n</code></pre> <p>You can then submit Pull Requests which will be carefully reviewed.</p> <p>If you have an issue, please report it here. If you have something to discuss, please report it here.</p>"},{"location":"faq/","title":"FAQ","text":"<p>The Frequently Asked Questions (FAQ) for the ANL competition will be collected in this document.</p> <p>If you have further questions, please get in contact with the organisers.</p>"},{"location":"install/","title":"Preparing Development Environment","text":"<p>To participate in ANL2025 2025, you need to prepare a local development environment in your machine, download the skeleton, and start hacking. This section of the documentation describes two ways to do that.</p> <p>This is the recommended method. It requires you to use an installation of python $3.11$ or later on your machine.</p>"},{"location":"install/#0-installing-python","title":"0. Installing Python","text":"<p>If -- for some reason -- you do not have python installed in your machine, start by installing it from python.org. You can also use any other method to install python 3.11 or later.</p>"},{"location":"install/#1-creating-and-activating-a-virtual-environment","title":"1. Creating and activating a virtual environment","text":"<p>Info</p> <p>optional but highly recommended</p> <p>As always recommended, you should create a virtual environment for your development. You can use your IDE to do that or simply run the following command: <pre><code>python -m venv .venv\n</code></pre> You should always activate your virtual environment using:</p> WindowsLinux/MacOS <pre><code>.venv\\Scripts\\activate.bat\n</code></pre> <pre><code>source .venv/bin/activate\n</code></pre> <p>Of course, you can use any other method for creating your virtual environment (e.g. anaconda, hatch, poetry, pyenv, virtualenv or any similar method). Whatever method you use, it is highly recommended not to install packages (anl2025 or otherwise) directly on your base python system.</p>"},{"location":"install/#2-installing-the-anl2025-package","title":"2. Installing the ANL2025 package","text":"<p>The second step is to install the <code>anl2025</code> package using:</p> <pre><code>python -m pip install anl2025\n</code></pre>"},{"location":"install/#3-development","title":"3. Development","text":"<p>The next step is to download the template from here. Please familiarize yourself with the competition rules available at the competition website. After downloading and uncompressing the template, you should do the following steps:</p> <ol> <li>Modify the name of the single class in <code>myagent.py</code> (currently called <code>MyNegotiator</code>) to a representative name for your agent. We will use <code>AwsomeNegotiator</code> here. You should then implement your agent logic by modifying this class.<ul> <li>Remember to change the name of the agent in the last line of the file to match your new class name (<code>AwsomeNegotiator</code>).</li> </ul> </li> <li>Start developing your agent as will be explained later in the tutorial.</li> <li> <p>You can use the following ways to test your agent:</p> <ul> <li>Run the following command to test your agent from the root folder of the extracted skeleton:   <pre><code>python -m myagent.myagent\n</code></pre></li> <li> <p>Use the <code>anl2025</code> command line utility from the root folder of the extracted skeleton:   <pre><code>anl2025 tournament run --generate=5\n</code></pre>   This method is more flexible as you can control all aspects of the tournament to run.   Use <code>anl2025 tournament run --help</code>  to see all available options.</p> </li> <li> <p>You can directly call <code>Tournament.from_scenarios()</code> passing your agent as one of the competitors. This is the most flexible method and will be used in the tutorial.</p> </li> </ul> </li> <li> <p>Submit your agent to the official submission website:</p> <ul> <li>Remember to update the <code>Class Name</code> (<code>AwsomeNegotiator</code> in our case) and <code>Agent Module</code> (<code>myagent.myagent</code> in our case) in the submission form on the  competition website to <code>AwsomeNegotiator</code>.</li> <li>If you need any libraries that are not already provided by <code>anl2025</code>, please include them in the <code>Dependencies</code> in a semi-colon separated list when submitting your agent.</li> </ul> </li> </ol>"},{"location":"reference/","title":"ANL 2025 Reference","text":"<p>This package provides a wrapper around NegMAS functionality to generate and run tournaments a la ANL 2025 competition. You mostly only need to use <code>anl2025_tournament</code> in your code. The other helpers are provided to allow for a finer control over the scenarios used.</p>"},{"location":"reference/#negotiators-agents","title":"Negotiators (Agents)","text":"<p>The package provides few example negotiators. Of special importance is the <code>MiCRO</code> negotiator which provides a full implementation of a recently proposed behavioral strategy. Other negotiators are just wrappers over negotiators provided by NegMAS.</p>"},{"location":"reference/#anl2025.negotiator.ANL2025Negotiator","title":"<code>anl2025.negotiator.ANL2025Negotiator</code>","text":"<p>               Bases: <code>SAOController</code></p> <p>Base class of all participant code.</p> <p>See the next two examples of how to implement it (<code>Boulware2025</code>, <code>RandomNegotiator</code>).</p> <p>Methods:</p> Name Description <code>init</code> <p>Called after all mechanisms are created to initialize</p> Source code in <code>anl2025/negotiator.py</code> <pre><code>class ANL2025Negotiator(SAOController):\n    \"\"\"\n    Base class of all participant code.\n\n    See the next two examples of how to implement it (`Boulware2025`, `RandomNegotiator`).\n    \"\"\"\n\n    def __init__(self, *args, n_edges: int = 0, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._n_edges = n_edges\n\n    def init(self):\n        \"\"\"Called after all mechanisms are created to initialize\"\"\"\n</code></pre>"},{"location":"reference/#anl2025.negotiator.ANL2025Negotiator.init","title":"<code>init</code>","text":"<p>Called after all mechanisms are created to initialize</p> Source code in <code>anl2025/negotiator.py</code> <pre><code>def init(self):\n    \"\"\"Called after all mechanisms are created to initialize\"\"\"\n</code></pre>"},{"location":"reference/#anl2025.negotiator.RandomNegotiator","title":"<code>anl2025.negotiator.RandomNegotiator</code>","text":"<p>               Bases: <code>ANL2025Negotiator</code></p> <p>The most general way to implement an agent is to implement propose and respond.</p> <p>Methods:</p> Name Description <code>propose</code> <p>Proposes to the given partner (dest) using the side negotiator (negotiator_id).</p> <code>respond</code> <p>Responds to the given partner (source) using the side negotiator (negotiator_id).</p> Source code in <code>anl2025/negotiator.py</code> <pre><code>class RandomNegotiator(ANL2025Negotiator):\n    \"\"\"\n    The most general way to implement an agent is to implement propose and respond.\n    \"\"\"\n\n    p_end = 0.03\n    p_reject = 0.999\n\n    def propose(\n        self, negotiator_id: str, state: SAOState, dest: str | None = None\n    ) -&gt; Outcome | None:\n        \"\"\"Proposes to the given partner (dest) using the side negotiator (negotiator_id).\n\n        Remarks:\n            - the mapping from negotiator_id to source is stable within a negotiation.\n        \"\"\"\n        nmi = self.negotiators[negotiator_id].negotiator.nmi\n        os: DiscreteCartesianOutcomeSpace = nmi.outcome_space\n        return list(os.sample(1))[0]\n\n    def respond(\n        self, negotiator_id: str, state: SAOState, source: str | None = None\n    ) -&gt; ResponseType:\n        \"\"\"Responds to the given partner (source) using the side negotiator (negotiator_id).\n\n        Remarks:\n            - negotiator_id is the ID of the side negotiator representing this agent.\n            - source: is the ID of the partner.\n            - the mapping from negotiator_id to source is stable within a negotiation.\n\n        \"\"\"\n\n        if random() &lt; self.p_end:\n            return ResponseType.END_NEGOTIATION\n\n        if random() &lt; self.p_reject:\n            return ResponseType.REJECT_OFFER\n        return ResponseType.ACCEPT_OFFER\n</code></pre>"},{"location":"reference/#anl2025.negotiator.RandomNegotiator.propose","title":"<code>propose</code>","text":"<p>Proposes to the given partner (dest) using the side negotiator (negotiator_id).</p> Remarks <ul> <li>the mapping from negotiator_id to source is stable within a negotiation.</li> </ul> Source code in <code>anl2025/negotiator.py</code> <pre><code>def propose(\n    self, negotiator_id: str, state: SAOState, dest: str | None = None\n) -&gt; Outcome | None:\n    \"\"\"Proposes to the given partner (dest) using the side negotiator (negotiator_id).\n\n    Remarks:\n        - the mapping from negotiator_id to source is stable within a negotiation.\n    \"\"\"\n    nmi = self.negotiators[negotiator_id].negotiator.nmi\n    os: DiscreteCartesianOutcomeSpace = nmi.outcome_space\n    return list(os.sample(1))[0]\n</code></pre>"},{"location":"reference/#anl2025.negotiator.RandomNegotiator.respond","title":"<code>respond</code>","text":"<p>Responds to the given partner (source) using the side negotiator (negotiator_id).</p> Remarks <ul> <li>negotiator_id is the ID of the side negotiator representing this agent.</li> <li>source: is the ID of the partner.</li> <li>the mapping from negotiator_id to source is stable within a negotiation.</li> </ul> Source code in <code>anl2025/negotiator.py</code> <pre><code>def respond(\n    self, negotiator_id: str, state: SAOState, source: str | None = None\n) -&gt; ResponseType:\n    \"\"\"Responds to the given partner (source) using the side negotiator (negotiator_id).\n\n    Remarks:\n        - negotiator_id is the ID of the side negotiator representing this agent.\n        - source: is the ID of the partner.\n        - the mapping from negotiator_id to source is stable within a negotiation.\n\n    \"\"\"\n\n    if random() &lt; self.p_end:\n        return ResponseType.END_NEGOTIATION\n\n    if random() &lt; self.p_reject:\n        return ResponseType.REJECT_OFFER\n    return ResponseType.ACCEPT_OFFER\n</code></pre>"},{"location":"reference/#anl2025.negotiator.Boulware2025","title":"<code>anl2025.negotiator.Boulware2025</code>","text":"<p>               Bases: <code>ANL2025Negotiator</code></p> <p>You can participate by an agent that runs any SAO negotiator independently for each thread.</p> Source code in <code>anl2025/negotiator.py</code> <pre><code>class Boulware2025(ANL2025Negotiator):\n    \"\"\"\n    You can participate by an agent that runs any SAO negotiator independently for each thread.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        kwargs[\"default_negotiator_type\"] = AspirationNegotiator\n        super().__init__(**kwargs)\n</code></pre>"},{"location":"reference/#anl2025.negotiator.Shochan2025","title":"<code>anl2025.negotiator.Shochan2025</code>","text":"<p>               Bases: <code>ANL2025Negotiator</code></p> <p>You can participate by an agent that runs any SAO negotiator independently for each thread.</p> Source code in <code>anl2025/negotiator.py</code> <pre><code>class Shochan2025(ANL2025Negotiator):\n    \"\"\"\n    You can participate by an agent that runs any SAO negotiator independently for each thread.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        kwargs[\"default_negotiator_type\"] = Shochan\n        super().__init__(**kwargs)\n</code></pre>"},{"location":"reference/#anl2025.negotiator.AgentRenting2025","title":"<code>anl2025.negotiator.AgentRenting2025</code>","text":"<p>               Bases: <code>ANL2025Negotiator</code></p> <p>You can participate by an agent that runs any SAO negotiator independently for each thread.</p> Source code in <code>anl2025/negotiator.py</code> <pre><code>class AgentRenting2025(ANL2025Negotiator):\n    \"\"\"\n    You can participate by an agent that runs any SAO negotiator independently for each thread.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        kwargs[\"default_negotiator_type\"] = AgentRenting2024\n        super().__init__(**kwargs)\n</code></pre>"},{"location":"reference/#utility-functions","title":"Utility Functions","text":""},{"location":"reference/#anl2025.ufun.CenterUFun","title":"<code>anl2025.ufun.CenterUFun</code>","text":"<p>               Bases: <code>UtilityFunction</code>, <code>ABC</code></p> <p>Base class of center utility functions.</p> Remarks <ul> <li>Can be constructed by either passing a single <code>outcome_space</code> and <code>n_edges</code> or a tuple of <code>outcome_spaces</code></li> <li>It's eval() method  receives a tuple of negotiation results and returns a float</li> </ul> <p>Methods:</p> Name Description <code>eval</code> <p>Evaluates the utility of a given set of offers.</p> <code>side_ufuns</code> <p>Should return an independent ufun for each side negotiator of the center.</p> Source code in <code>anl2025/ufun.py</code> <pre><code>class CenterUFun(UtilityFunction, ABC):\n    \"\"\"\n    Base class of center utility functions.\n\n    Remarks:\n        - Can be constructed by either passing a single `outcome_space` and `n_edges` or a tuple of `outcome_spaces`\n        - It's eval() method  receives a tuple of negotiation results and returns a float\n    \"\"\"\n\n    def __init__(\n        self,\n        *args,\n        outcome_spaces: tuple[OutcomeSpace, ...] = (),\n        n_edges: int = 0,\n        **kwargs,\n    ):\n        super().__init__(*args, **kwargs)\n        if not outcome_spaces and self.outcome_space:\n            outcome_spaces = tuple([self.outcome_space] * n_edges)\n        self._outcome_spaces = outcome_spaces\n        self.n_edges = len(outcome_spaces)\n        self.__kwargs = dict(\n            reserved_value=self.reserved_value,\n            owner=self.owner,\n            invalid_value=self._invalid_value,\n            name=self.name,\n            id=self.id,\n        )\n        try:\n            self.outcome_space, self.__nissues = flatten_outcome_spaces(\n                outcome_spaces, add_index_to_issue_names=True, add_os_to_issue_name=True\n            )\n        except Exception:\n            warn(\"Failed to find the Cartesian product of input outcome spaces\")\n            self.outcome_space, self.__nissues = None, tuple()\n\n    @property\n    def outcome_spaces(self) -&gt; tuple[OutcomeSpace, ...]:\n        return self._outcome_spaces\n\n    def flatten(\n        self,\n        add_index_to_issue_names: bool = False,\n        add_os_to_issue_name: bool = False,\n    ) -&gt; \"FlatCenterUFun\":\n        os = flatten_outcome_spaces(\n            self._outcome_spaces, add_index_to_issue_names, add_os_to_issue_name\n        )\n        return FlatCenterUFun(\n            base_ufun=self, nissues=self.__nissues, outcome_space=os, **self.__kwargs\n        )\n\n    @abstractmethod\n    def eval(self, offer: tuple[Outcome | None, ...] | None) -&gt; float:\n        \"\"\"\n        Evaluates the utility of a given set of offers.\n\n        Remarks:\n            - Order matters: The order of outcomes in the offer is stable over all calls.\n            - A missing offer is represented by `None`\n        \"\"\"\n\n    def side_ufuns(self, n_edges: int) -&gt; tuple[BaseUtilityFunction | None, ...]:\n        \"\"\"Should return an independent ufun for each side negotiator of the center.\"\"\"\n        return tuple(\n            SideUFun(center_ufun=self, n_edges=self.n_edges, index=i)\n            for i in range(n_edges)\n        )\n</code></pre>"},{"location":"reference/#anl2025.ufun.CenterUFun.eval","title":"<code>eval</code>  <code>abstractmethod</code>","text":"<p>Evaluates the utility of a given set of offers.</p> Remarks <ul> <li>Order matters: The order of outcomes in the offer is stable over all calls.</li> <li>A missing offer is represented by <code>None</code></li> </ul> Source code in <code>anl2025/ufun.py</code> <pre><code>@abstractmethod\ndef eval(self, offer: tuple[Outcome | None, ...] | None) -&gt; float:\n    \"\"\"\n    Evaluates the utility of a given set of offers.\n\n    Remarks:\n        - Order matters: The order of outcomes in the offer is stable over all calls.\n        - A missing offer is represented by `None`\n    \"\"\"\n</code></pre>"},{"location":"reference/#anl2025.ufun.CenterUFun.side_ufuns","title":"<code>side_ufuns</code>","text":"<p>Should return an independent ufun for each side negotiator of the center.</p> Source code in <code>anl2025/ufun.py</code> <pre><code>def side_ufuns(self, n_edges: int) -&gt; tuple[BaseUtilityFunction | None, ...]:\n    \"\"\"Should return an independent ufun for each side negotiator of the center.\"\"\"\n    return tuple(\n        SideUFun(center_ufun=self, n_edges=self.n_edges, index=i)\n        for i in range(n_edges)\n    )\n</code></pre>"},{"location":"reference/#anl2025.ufun.FlatCenterUFun","title":"<code>anl2025.ufun.FlatCenterUFun</code>","text":"<p>               Bases: <code>UtilityFunction</code></p> <p>A flattened version of a center ufun.</p> <p>A normal CenterUFun takes outcomes as a tuple of outcomes (one for each edge). A flattened version of the same ufun takes input as just a single outcome containing a concatenation of the outcomes in all edges.</p> <p>Example:</p> <pre><code>```python\nx = CenterUFun(...)\ny = x.flatten()\n\nx(((1, 0.5), (3, true), (7,))) == y((1, 0.5, 3 , true, 7))\n```\n</code></pre> Source code in <code>anl2025/ufun.py</code> <pre><code>class FlatCenterUFun(UtilityFunction):\n    \"\"\"\n    A flattened version of a center ufun.\n\n    A normal CenterUFun takes outcomes as a tuple of outcomes (one for each edge).\n    A flattened version of the same ufun takes input as just a single outcome containing\n    a concatenation of the outcomes in all edges.\n\n    Example:\n\n        ```python\n        x = CenterUFun(...)\n        y = x.flatten()\n\n        x(((1, 0.5), (3, true), (7,))) == y((1, 0.5, 3 , true, 7))\n        ```\n    \"\"\"\n\n    def __init__(\n        self, *args, base_ufun: CenterUFun, nissues: tuple[int, ...], **kwargs\n    ):\n        super().__init__(*args, **kwargs)\n        self.__base = base_ufun\n        self.__nissues = list(nissues)\n\n    def _unflatten(self, outcome: Outcome) -&gt; tuple[Outcome, ...]:\n        beg = [0] + self.__nissues[:-1]\n        end = self.__nissues\n        outcomes = []\n        for i, j in zip(beg, end, strict=True):\n            outcomes.append(tuple(outcome[i:j]))\n        return tuple(outcomes)\n\n    def eval(self, offer: Outcome) -&gt; float:\n        return self.__base.eval(self._unflatten(offer))\n</code></pre>"},{"location":"reference/#anl2025.ufun.LambdaCenterUFun","title":"<code>anl2025.ufun.LambdaCenterUFun</code>","text":"<p>               Bases: <code>CenterUFun</code></p> <p>A center utility function that implements an arbitrary evaluator</p> Source code in <code>anl2025/ufun.py</code> <pre><code>class LambdaCenterUFun(CenterUFun):\n    \"\"\"\n    A center utility function that implements an arbitrary evaluator\n    \"\"\"\n\n    def __init__(self, *args, evaluator: CenterEvaluator, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._eval = evaluator\n\n    def eval(self, offer: tuple[Outcome | None, ...] | None) -&gt; float:\n        return self._eval(offer)\n\n    @classmethod\n    def load(cls, folder: Path):\n        pass\n</code></pre>"},{"location":"reference/#anl2025.ufun.LambdaUtilityFunction","title":"<code>anl2025.ufun.LambdaUtilityFunction</code>","text":"<p>               Bases: <code>UtilityFunction</code></p> <p>A utility function that implements an arbitrary mapping</p> Source code in <code>anl2025/ufun.py</code> <pre><code>class LambdaUtilityFunction(UtilityFunction):\n    \"\"\"A utility function that implements an arbitrary mapping\"\"\"\n\n    def __init__(self, *args, evaluator: EdgeEvaluator, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._evaluator = evaluator\n\n    def __call__(self, offer: Outcome | None) -&gt; float:\n        return self._evaluator(offer)\n\n    def eval(self, offer: Outcome) -&gt; float:\n        return self._evaluator(offer)\n</code></pre>"},{"location":"reference/#anl2025.ufun.MaxCenterUFun","title":"<code>anl2025.ufun.MaxCenterUFun</code>","text":"<p>               Bases: <code>UtilityCombiningCenterUFun</code></p> <p>The max center ufun.</p> <p>The utility of the center is the maximum of the utilities it got in each negotiation (called side utilities)</p> Source code in <code>anl2025/ufun.py</code> <pre><code>class MaxCenterUFun(UtilityCombiningCenterUFun):\n    \"\"\"\n    The max center ufun.\n\n    The utility of the center is the maximum of the utilities it got in each negotiation (called side utilities)\n    \"\"\"\n\n    def combine(self, values: Sequence[float]) -&gt; float:\n        return max(values)\n</code></pre>"},{"location":"reference/#anl2025.ufun.MeanSMCenterUFun","title":"<code>anl2025.ufun.MeanSMCenterUFun</code>","text":"<p>               Bases: <code>SingleAgreementSideUFunMixin</code>, <code>CenterUFun</code></p> <p>A ufun that just  returns the average mean+std dev. in each issue of the agreements as the utility value</p> Source code in <code>anl2025/ufun.py</code> <pre><code>class MeanSMCenterUFun(SingleAgreementSideUFunMixin, CenterUFun):\n    \"\"\"A ufun that just  returns the average mean+std dev. in each issue of the agreements as the utility value\"\"\"\n\n    def eval(self, offer: tuple[Outcome | None, ...] | None) -&gt; float:\n        if not offer:\n            return 0.0\n        n_edges = len(offer)\n        if n_edges &lt; 2:\n            return 0.1\n        vals = defaultdict(lambda: [0.0] * n_edges)\n        for e, outcome in enumerate(offer):\n            if not outcome:\n                continue\n            for i, v in enumerate(outcome):\n                try:\n                    vals[e][i] = float(v[1:])\n                except Exception:\n                    pass\n\n        return float(sum(np.mean(x) + np.std(x) for x in vals.values())) / len(vals)\n</code></pre>"},{"location":"reference/#anl2025.ufun.SideUFun","title":"<code>anl2025.ufun.SideUFun</code>","text":"<p>               Bases: <code>BaseUtilityFunction</code></p> <p>Side ufun corresponding to the i's component of a center ufun.</p> Source code in <code>anl2025/ufun.py</code> <pre><code>class SideUFun(BaseUtilityFunction):\n    \"\"\"\n    Side ufun corresponding to the i's component of a center ufun.\n    \"\"\"\n\n    def __init__(\n        self, *args, center_ufun: CenterUFun, index: int, n_edges: int, **kwargs\n    ):\n        super().__init__(*args, **kwargs)\n        self.__center_ufun = center_ufun\n        self.__index = index\n        self.__n_edges = n_edges\n\n    def eval(self, offer: Outcome | None) -&gt; float:\n        offers: list[Outcome | None] = [None] * self.__n_edges\n        offers[self.__index] = offer\n        return self.__center_ufun(tuple(offers))\n</code></pre>"},{"location":"reference/#anl2025.ufun.SingleAgreementSideUFunMixin","title":"<code>anl2025.ufun.SingleAgreementSideUFunMixin</code>","text":"<p>Can be mixed with any CenterUFun that is not a combining ufun to create side_ufuns that assume failure on all other negotiations.</p> See Also <p><code>MeanSMCenterUFun</code></p> <p>Methods:</p> Name Description <code>side_ufuns</code> <p>Should return an independent ufun for each side negotiator of the center</p> Source code in <code>anl2025/ufun.py</code> <pre><code>class SingleAgreementSideUFunMixin:\n    \"\"\"Can be mixed with any CenterUFun that is not a combining ufun to create side_ufuns that assume failure on all other negotiations.\n\n    See Also:\n        `MeanSMCenterUFun`\n    \"\"\"\n\n    def side_ufuns(self, n_edges: int) -&gt; tuple[BaseUtilityFunction, ...]:\n        \"\"\"Should return an independent ufun for each side negotiator of the center\"\"\"\n        return tuple(\n            SideUFun(center_ufun=self, n_edges=n_edges, index=i)  # type: ignore\n            for i in range(n_edges)\n        )\n</code></pre>"},{"location":"reference/#anl2025.ufun.SingleAgreementSideUFunMixin.side_ufuns","title":"<code>side_ufuns</code>","text":"<p>Should return an independent ufun for each side negotiator of the center</p> Source code in <code>anl2025/ufun.py</code> <pre><code>def side_ufuns(self, n_edges: int) -&gt; tuple[BaseUtilityFunction, ...]:\n    \"\"\"Should return an independent ufun for each side negotiator of the center\"\"\"\n    return tuple(\n        SideUFun(center_ufun=self, n_edges=n_edges, index=i)  # type: ignore\n        for i in range(n_edges)\n    )\n</code></pre>"},{"location":"reference/#anl2025.ufun.UtilityCombiningCenterUFun","title":"<code>anl2025.ufun.UtilityCombiningCenterUFun</code>","text":"<p>               Bases: <code>CenterUFun</code></p> <p>A center ufun with a side-ufun defined for each thread.</p> <p>The utility of the center is a function of the ufuns of the edges.</p> <p>Methods:</p> Name Description <code>combine</code> <p>Combines the utilities of all negotiation  threads into a single value</p> Source code in <code>anl2025/ufun.py</code> <pre><code>class UtilityCombiningCenterUFun(CenterUFun):\n    \"\"\"\n    A center ufun with a side-ufun defined for each thread.\n\n    The utility of the center is a function of the ufuns of the edges.\n    \"\"\"\n\n    def __init__(self, *args, ufuns: tuple[BaseUtilityFunction, ...], **kwargs):\n        super().__init__(*args, **kwargs)\n        self._ufuns = ufuns\n\n    @abstractmethod\n    def combine(self, values: Sequence[float]) -&gt; float:\n        \"\"\"Combines the utilities of all negotiation  threads into a single value\"\"\"\n\n    def eval(self, offer: tuple[Outcome | None, ...] | None) -&gt; float:\n        if not offer:\n            return self.reserved_value\n        return self.combine(tuple(float(u(_)) for u, _ in zip(self._ufuns, offer)))\n\n    def side_ufuns(self, n_edges: int) -&gt; tuple[BaseUtilityFunction, ...]:\n        assert (\n            n_edges == len(self._ufuns)\n        ), f\"Initialized with {len(self._ufuns)} ufuns but you are asking for ufuns for {n_edges} side negotiators.\"\n        return self._ufuns\n</code></pre>"},{"location":"reference/#anl2025.ufun.UtilityCombiningCenterUFun.combine","title":"<code>combine</code>  <code>abstractmethod</code>","text":"<p>Combines the utilities of all negotiation  threads into a single value</p> Source code in <code>anl2025/ufun.py</code> <pre><code>@abstractmethod\ndef combine(self, values: Sequence[float]) -&gt; float:\n    \"\"\"Combines the utilities of all negotiation  threads into a single value\"\"\"\n</code></pre>"},{"location":"reference/#utility-function-helpers","title":"Utility Function Helpers","text":""},{"location":"reference/#anl2025.ufun.convert_to_center_ufun","title":"<code>anl2025.ufun.convert_to_center_ufun</code>","text":"<p>Creates a center ufun from any standard ufun with ufuns side ufuns</p> Source code in <code>anl2025/ufun.py</code> <pre><code>def convert_to_center_ufun(\n    ufun: UtilityFunction,\n    nissues: tuple[int],\n    side_evaluators: list[EdgeEvaluator] | None = None,\n) -&gt; \"CenterUFun\":\n    \"\"\"Creates a center ufun from any standard ufun with ufuns side ufuns\"\"\"\n    assert ufun.outcome_space and isinstance(ufun.outcome_space, CartesianOutcomeSpace)\n    evaluator = ufun\n    if side_evaluators is not None:\n        return LambdaCenterUFunWithSides(\n            outcome_spaces=unflatten_outcome_space(ufun.outcome_space, nissues),\n            evaluator=evaluator,\n            side_evaluators=tuple(side_evaluators),\n        )\n    return LambdaCenterUFun(\n        outcome_spaces=unflatten_outcome_space(ufun.outcome_space, nissues),\n        evaluator=evaluator,\n    )\n</code></pre>"},{"location":"reference/#anl2025.ufun.flatten_outcome_spaces","title":"<code>anl2025.ufun.flatten_outcome_spaces</code>","text":"<p>Generates a single outcome-space which is the Cartesian product of input outcome_spaces.</p> Source code in <code>anl2025/ufun.py</code> <pre><code>def flatten_outcome_spaces(\n    outcome_spaces: tuple[OutcomeSpace, ...],\n    add_index_to_issue_names: bool = False,\n    add_os_to_issue_name: bool = False,\n) -&gt; tuple[CartesianOutcomeSpace, tuple[int, ...]]:\n    \"\"\"Generates a single outcome-space which is the Cartesian product of input outcome_spaces.\"\"\"\n\n    def _name(i: int, os_name: str | None, issue_name: str | None) -&gt; str:\n        x = issue_name if issue_name else \"\"\n        if add_os_to_issue_name and os_name:\n            x = f\"{os_name}:{x}\"\n        if add_index_to_issue_names:\n            x = f\"{x}:{i}\"\n        return x\n\n    values, names, nissues = [], [], []\n    for i, os in enumerate(outcome_spaces):\n        if isinstance(os, EnumeratingOutcomeSpace):\n            values.append(list(os.enumerate()))\n            names.append(_name(i, \"\", os.name))\n            nissues.append(1)\n        elif isinstance(os, CartesianOutcomeSpace):\n            for issue in os.issues:\n                values.append(issue.values)\n                names.append(_name(i, os.name, issue.name))\n            nissues.append(len(os.issues))\n        else:\n            raise TypeError(\n                f\"Outcome space of type {type(os)} cannot be combined with other outcome-spaces\"\n            )\n    return make_os([make_issue(v, n) for v, n in zip(values, names)]), tuple(nissues)\n</code></pre>"},{"location":"reference/#anl2025.ufun.unflatten_outcome_space","title":"<code>anl2025.ufun.unflatten_outcome_space</code>","text":"<p>Distributes the issues of an outcome-space into a tuple of outcome-spaces.</p> Source code in <code>anl2025/ufun.py</code> <pre><code>def unflatten_outcome_space(\n    outcome_space: CartesianOutcomeSpace, nissues: tuple[int, ...] | list[int]\n) -&gt; tuple[CartesianOutcomeSpace, ...]:\n    \"\"\"Distributes the issues of an outcome-space into a tuple of outcome-spaces.\"\"\"\n    nissues = list(nissues)\n    beg = [0] + nissues[:-1]\n    end = nissues\n    return tuple(\n        make_os(outcome_space.issues[i:j], name=f\"OS{i}\")\n        for i, j in zip(beg, end, strict=True)\n    )\n</code></pre>"},{"location":"reference/#scenarios","title":"Scenarios","text":""},{"location":"reference/#anl2025.scenario.MultidealScenario","title":"<code>anl2025.scenario.MultidealScenario</code>","text":"<p>Defines the multi-deal scenario by setting utility functions (and implicitly outcome-spaces)</p> <p>Methods:</p> Name Description <code>from_folder</code> <p>Loads a multi-deal scenario from the given folder.</p> <code>to_dict</code> <p>Converts the scenario to a dictionary</p> Source code in <code>anl2025/scenario.py</code> <pre><code>@define\nclass MultidealScenario:\n    \"\"\"Defines the multi-deal scenario by setting utility functions (and implicitly outcome-spaces)\"\"\"\n\n    center_ufun: CenterUFun\n    edge_ufuns: tuple[UtilityFunction, ...]\n    side_ufuns: tuple[UtilityFunction, ...] | None = None\n    name: str = \"\"\n\n    def save(\n        self,\n        base: Path,\n        as_folder: bool = True,\n        python_class_identifier: str = TYPE_IDENTIFIER,\n    ):\n        name = self.name if self.name else \"scenario\"\n        if as_folder:\n            return self.to_folder(\n                folder=base / name,\n                mkdir=False,\n                python_class_identifier=python_class_identifier,\n            )\n        return self.to_file(\n            path=base / f\"{name}.yml\", python_class_identifier=python_class_identifier\n        )\n\n    @classmethod\n    def from_folder(\n        cls,\n        folder: Path,\n        name: str | None = None,\n        edges_know_details: bool = True,\n        python_class_identifier: str = TYPE_IDENTIFIER,\n        type_marker=f\"{TYPE_IDENTIFIER}:\",\n    ) -&gt; Optional[\"MultidealScenario\"]:\n        \"\"\"\n        Loads a multi-deal scenario from the given folder.\n\n        Args:\n            folder: The path to load the scenario from\n            name: The name to give to the scenario. If not given, the folder name\n            edges_know_details: If given, edge ufuns will have `n_edges`, `outcome_spaces` members\n                                that reveal the number of edges in total and the outcome space for each\n                                negotiation thread.\n            python_class_identifier: the key in the yaml to define a type.\n            type_marker: A marker at the beginning of a string to define a type (for future proofing).\n        \"\"\"\n        folder = folder.resolve()\n        center_file = folder / CENTER_FILE_NAME\n        if not center_file.is_file():\n            return None\n        dparams = dict(\n            python_class_identifier=python_class_identifier,\n            type_marker=type_marker,\n            type_name_adapter=type_name_adapter,\n        )\n        sys.path.append(str(folder))\n        center_ufun = deserialize(load(center_file), **dparams)  # type: ignore\n        assert isinstance(center_ufun, CenterUFun)\n\n        def load_ufuns(f: Path) -&gt; tuple[UtilityFunction, ...] | None:\n            if not f.is_dir():\n                return None\n            return tuple(\n                deserialize(load(_), **dparams)  # type: ignore\n                for _ in f.glob(\"*.yml\")\n            )\n\n        edge_ufuns = load_ufuns(folder / EDGES_FOLDER_NAME)\n        assert edge_ufuns\n        for u, os in zip(edge_ufuns, center_ufun.outcome_spaces):\n            if u.outcome_space is None:\n                u.outcome_space = os\n        if edges_know_details:\n            for u in edge_ufuns:\n                u.n_edges = center_ufun.n_edges  # type: ignore\n                u.outcome_spaces = tuple(  # type: ignore\n                    copy.deepcopy(_) for _ in center_ufun.outcome_spaces\n                )\n        side_ufuns = load_ufuns(folder / SIDES_FILDER_NAME)\n\n        return cls(\n            center_ufun=center_ufun,\n            edge_ufuns=tuple(edge_ufuns),\n            side_ufuns=side_ufuns,\n            name=folder.name if name is None else name,\n        )\n\n    def to_folder(\n        self,\n        folder: Path,\n        python_class_identifier: str = TYPE_IDENTIFIER,\n        mkdir: bool = False,\n    ):\n        if mkdir:\n            name = self.name if self.name else \"scenario\"\n            folder = folder / name\n\n        folder.mkdir(parents=True, exist_ok=True)\n        dump(\n            serialize(\n                self.center_ufun, python_class_identifier=python_class_identifier\n            ),\n            folder / CENTER_FILE_NAME,\n        )\n\n        def save(fname, ufuns):\n            if ufuns is None:\n                return\n            base = folder / fname\n            base.mkdir(parents=True, exist_ok=True)\n            for u in ufuns:\n                dump(\n                    serialize(u, python_class_identifier=python_class_identifier),\n                    base / f\"{u.name}.yml\",\n                )\n\n        save(EDGES_FOLDER_NAME, self.edge_ufuns)\n        save(SIDES_FILDER_NAME, self.side_ufuns)\n\n    def to_dict(self, python_class_identifier=TYPE_IDENTIFIER) -&gt; dict[str, Any]:\n        \"\"\"Converts the scenario to a dictionary\"\"\"\n        return dict(\n            name=self.name,\n            center_ufun=serialize(\n                self.center_ufun, python_class_identifier=python_class_identifier\n            ),\n            edge_ufuns=serialize(\n                self.edge_ufuns, python_class_identifier=python_class_identifier\n            ),\n            side_ufuns=serialize(\n                self.side_ufuns, python_class_identifier=python_class_identifier\n            ),\n        )\n\n    @classmethod\n    def from_dict(\n        cls, d: dict[str, Any], python_class_identifier=TYPE_IDENTIFIER\n    ) -&gt; Optional[\"MultidealScenario\"]:\n        return deserialize(d, python_class_identifier=python_class_identifier)  # type: ignore\n\n    def to_file(self, path: Path, python_class_identifier=TYPE_IDENTIFIER):\n        dump(self.to_dict(python_class_identifier=python_class_identifier), path)\n\n    @classmethod\n    def from_file(\n        cls, path: Path, python_class_identifier=TYPE_IDENTIFIER\n    ) -&gt; Optional[\"MultidealScenario\"]:\n        return cls.to_dict(load(path), python_class_identifier=python_class_identifier)  # type: ignore\n</code></pre>"},{"location":"reference/#anl2025.scenario.MultidealScenario.from_folder","title":"<code>from_folder</code>  <code>classmethod</code>","text":"<p>Loads a multi-deal scenario from the given folder.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>Path</code> <p>The path to load the scenario from</p> required <code>name</code> <code>str | None</code> <p>The name to give to the scenario. If not given, the folder name</p> <code>None</code> <code>edges_know_details</code> <code>bool</code> <p>If given, edge ufuns will have <code>n_edges</code>, <code>outcome_spaces</code> members                 that reveal the number of edges in total and the outcome space for each                 negotiation thread.</p> <code>True</code> <code>python_class_identifier</code> <code>str</code> <p>the key in the yaml to define a type.</p> <code>TYPE_IDENTIFIER</code> <code>type_marker</code> <p>A marker at the beginning of a string to define a type (for future proofing).</p> <code>f'{TYPE_IDENTIFIER}:'</code> Source code in <code>anl2025/scenario.py</code> <pre><code>@classmethod\ndef from_folder(\n    cls,\n    folder: Path,\n    name: str | None = None,\n    edges_know_details: bool = True,\n    python_class_identifier: str = TYPE_IDENTIFIER,\n    type_marker=f\"{TYPE_IDENTIFIER}:\",\n) -&gt; Optional[\"MultidealScenario\"]:\n    \"\"\"\n    Loads a multi-deal scenario from the given folder.\n\n    Args:\n        folder: The path to load the scenario from\n        name: The name to give to the scenario. If not given, the folder name\n        edges_know_details: If given, edge ufuns will have `n_edges`, `outcome_spaces` members\n                            that reveal the number of edges in total and the outcome space for each\n                            negotiation thread.\n        python_class_identifier: the key in the yaml to define a type.\n        type_marker: A marker at the beginning of a string to define a type (for future proofing).\n    \"\"\"\n    folder = folder.resolve()\n    center_file = folder / CENTER_FILE_NAME\n    if not center_file.is_file():\n        return None\n    dparams = dict(\n        python_class_identifier=python_class_identifier,\n        type_marker=type_marker,\n        type_name_adapter=type_name_adapter,\n    )\n    sys.path.append(str(folder))\n    center_ufun = deserialize(load(center_file), **dparams)  # type: ignore\n    assert isinstance(center_ufun, CenterUFun)\n\n    def load_ufuns(f: Path) -&gt; tuple[UtilityFunction, ...] | None:\n        if not f.is_dir():\n            return None\n        return tuple(\n            deserialize(load(_), **dparams)  # type: ignore\n            for _ in f.glob(\"*.yml\")\n        )\n\n    edge_ufuns = load_ufuns(folder / EDGES_FOLDER_NAME)\n    assert edge_ufuns\n    for u, os in zip(edge_ufuns, center_ufun.outcome_spaces):\n        if u.outcome_space is None:\n            u.outcome_space = os\n    if edges_know_details:\n        for u in edge_ufuns:\n            u.n_edges = center_ufun.n_edges  # type: ignore\n            u.outcome_spaces = tuple(  # type: ignore\n                copy.deepcopy(_) for _ in center_ufun.outcome_spaces\n            )\n    side_ufuns = load_ufuns(folder / SIDES_FILDER_NAME)\n\n    return cls(\n        center_ufun=center_ufun,\n        edge_ufuns=tuple(edge_ufuns),\n        side_ufuns=side_ufuns,\n        name=folder.name if name is None else name,\n    )\n</code></pre>"},{"location":"reference/#anl2025.scenario.MultidealScenario.to_dict","title":"<code>to_dict</code>","text":"<p>Converts the scenario to a dictionary</p> Source code in <code>anl2025/scenario.py</code> <pre><code>def to_dict(self, python_class_identifier=TYPE_IDENTIFIER) -&gt; dict[str, Any]:\n    \"\"\"Converts the scenario to a dictionary\"\"\"\n    return dict(\n        name=self.name,\n        center_ufun=serialize(\n            self.center_ufun, python_class_identifier=python_class_identifier\n        ),\n        edge_ufuns=serialize(\n            self.edge_ufuns, python_class_identifier=python_class_identifier\n        ),\n        side_ufuns=serialize(\n            self.side_ufuns, python_class_identifier=python_class_identifier\n        ),\n    )\n</code></pre>"},{"location":"reference/#anl2025.scenario.make_multideal_scenario","title":"<code>anl2025.scenario.make_multideal_scenario</code>","text":"Source code in <code>anl2025/scenario.py</code> <pre><code>def make_multideal_scenario(\n    nedges: int = 10,\n    nissues: int = 3,\n    nvalues: int = 7,\n    # edge ufuns\n    center_reserved_value_min: float = 0.0,\n    center_reserved_value_max: float = 0.0,\n    center_ufun_type: str | type[CenterUFun] = \"MaxCenterUFun\",\n    center_ufun_params: dict[str, Any] | None = None,\n    # edge ufuns\n    edge_reserved_value_min: float = 0.1,\n    edge_reserved_value_max: float = 0.4,\n) -&gt; MultidealScenario:\n    ufuns = [generate_multi_issue_ufuns(nissues, nvalues) for _ in range(nedges)]\n    edge_ufuns = [_[0] for _ in ufuns]\n    for u in edge_ufuns:\n        u.reserved_value = sample_between(\n            edge_reserved_value_min, edge_reserved_value_max\n        )\n    # side ufuns are utilities of the center on individual threads (may or may not be used, see next comment)\n    side_ufuns = tuple(_[1] for _ in ufuns)\n    # create center ufun using side-ufuns if possible and without them otherwise.\n    center_r = sample_between(center_reserved_value_min, center_reserved_value_max)\n    utype = get_ufun_class(center_ufun_type)\n    center_ufun_params = center_ufun_params if center_ufun_params else dict()\n    try:\n        center_ufun = utype(\n            ufuns=side_ufuns,\n            reserved_value=center_r,\n            outcome_spaces=tuple(u.outcome_space for u in side_ufuns),  # type: ignore\n            **center_ufun_params,\n        )\n    except TypeError:\n        # if the center ufun does not take `ufuns` as an input, do not pass it\n        center_ufun = utype(\n            reserved_value=center_r,\n            outcome_spaces=tuple(u.outcome_space for u in side_ufuns),  # type: ignore\n            **center_ufun_params,\n        )\n\n    return MultidealScenario(\n        center_ufun=center_ufun,\n        side_ufuns=side_ufuns,\n        edge_ufuns=tuple(edge_ufuns),\n    )\n</code></pre>"},{"location":"reference/#sessions","title":"Sessions","text":""},{"location":"reference/#anl2025.runner.run_session","title":"<code>anl2025.runner.run_session</code>","text":"<p>Runs a multideal negotiation session and runs it.</p> <p>Parameters:</p> Name Type Description Default <code>scenario</code> <code>MultidealScenario</code> <p>The negotiation scenario (must be <code>MultidealScenario</code>).</p> required <code>method</code> <p>the method to use for running all the sessions.     Acceptable options are: sequential, ordered, threads, processes.     See <code>negmas.mechanisms.Mechanism.run_all()</code> for full details.</p> <code>DEFAULT_METHOD</code> <code>center_type</code> <code>str</code> <p>Type of the center agent</p> <code>'Boulware2025'</code> <code>center_params</code> <code>dict[str, Any] | None</code> <p>Optional parameters to pass to the center agent.</p> <code>None</code> <code>center_ufun_type</code> <p>Type of the center agent ufun.</p> required <code>center_ufun_params</code> <p>Parameters to pass to the center agent ufun.</p> required <code>edge_types</code> <code>list[str | type[ANL2025Negotiator]]</code> <p>Types of edge agents</p> <code>[Boulware2025, RandomNegotiator, Shochan2025, AgentRenting2025]</code> <code>nsteps</code> <code>int</code> <p>Number of negotiation steps.</p> <code>100</code> <code>keep_order</code> <code>bool</code> <p>Keep the order of edges when advancing the negotiation.</p> <code>False</code> <code>share_ufuns</code> <code>bool</code> <p>If given, agents will have access to partner ufuns through <code>self.opponent_ufun</code>.</p> <code>False</code> <code>atomic</code> <code>bool</code> <p>If given, one step corresponds to one offer instead of a full round.</p> <code>False</code> <code>output</code> <code>Path | None</code> <p>Folder to store the logs and results within.</p> <code>home() / 'negmas' / 'anl2025' / 'session'</code> <code>name</code> <code>str</code> <p>Name of the session</p> <code>''</code> <code>dry</code> <code>bool</code> <p>IF true, nothing will be run.</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>Print progress</p> <code>False</code> <p>Returns:</p> Type Description <code>SessionResults</code> <p><code>SessionResults</code> giving the results of the multideal negotiation session.</p> Source code in <code>anl2025/runner.py</code> <pre><code>def run_session(\n    scenario: MultidealScenario,\n    # center\n    center_type: str = \"Boulware2025\",\n    center_params: dict[str, Any] | None = None,\n    # edges\n    edge_types: list[str | type[ANL2025Negotiator]] = [\n        Boulware2025,\n        RandomNegotiator,\n        Shochan2025,\n        AgentRenting2025,\n    ],\n    # mechanism params\n    nsteps: int = 100,\n    keep_order: bool = False,\n    share_ufuns: bool = False,\n    atomic: bool = False,\n    # output and logging\n    output: Path | None = Path.home() / \"negmas\" / \"anl2025\" / \"session\",\n    name: str = \"\",\n    dry: bool = True,\n    method=DEFAULT_METHOD,\n    verbose: bool = False,\n) -&gt; SessionResults:\n    \"\"\"Runs a multideal negotiation session and runs it.\n\n    Args:\n        scenario: The negotiation scenario (must be `MultidealScenario`).\n        method: the method to use for running all the sessions.\n                Acceptable options are: sequential, ordered, threads, processes.\n                See `negmas.mechanisms.Mechanism.run_all()` for full details.\n        center_type: Type of the center agent\n        center_params: Optional parameters to pass to the center agent.\n        center_ufun_type: Type of the center agent ufun.\n        center_ufun_params: Parameters to pass to the center agent ufun.\n        edge_types: Types of edge agents\n        nsteps: Number of negotiation steps.\n        keep_order: Keep the order of edges when advancing the negotiation.\n        share_ufuns: If given, agents will have access to partner ufuns through `self.opponent_ufun`.\n        atomic: If given, one step corresponds to one offer instead of a full round.\n        output: Folder to store the logs and results within.\n        name: Name of the session\n        dry: IF true, nothing will be run.\n        verbose: Print progress\n\n    Returns:\n        `SessionResults` giving the results of the multideal negotiation session.\n    \"\"\"\n    run_params = RunParams(\n        nsteps=nsteps,\n        keep_order=keep_order,\n        share_ufuns=share_ufuns,\n        atomic=atomic,\n        method=method,\n    )\n    assigned = assign_scenario(\n        scenario=scenario,\n        run_params=run_params,\n        center_type=center_type,\n        center_params=center_params,\n        edge_types=edge_types,\n        verbose=verbose,\n        sample_edges=True,\n    )\n    return assigned.run(output=output, name=name, dry=dry, verbose=verbose)\n</code></pre>"},{"location":"reference/#anl2025.runner.run_generated_session","title":"<code>anl2025.runner.run_generated_session</code>","text":"<p>Generates a multideal negotiation session and runs it.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <p>the method to use for running all the sessions.     Acceptable options are: sequential, ordered, threads, processes.     See <code>negmas.mechanisms.Mechanism.run_all()</code> for full details.</p> <code>DEFAULT_METHOD</code> <code>center_type</code> <code>str</code> <p>Type of the center agent</p> <code>'Boulware2025'</code> <code>center_params</code> <code>dict[str, Any] | None</code> <p>Optional parameters to pass to the center agent.</p> <code>None</code> <code>center_reserved_value_min</code> <code>float</code> <p>Minimum reserved value for the center agent.</p> <code>0.0</code> <code>center_reserved_value_max</code> <code>float</code> <p>Maximum reserved value for the center agent.</p> <code>0.0</code> <code>center_ufun_type</code> <code>str | type[CenterUFun]</code> <p>Type of the center agent ufun.</p> <code>'MaxCenterUFun'</code> <code>center_ufun_params</code> <code>dict[str, Any] | None</code> <p>Parameters to pass to the center agent ufun.</p> <code>None</code> <code>nedges</code> <code>int</code> <p>Number of edges.</p> <code>10</code> <code>edge_reserved_value_min</code> <code>float</code> <p>Minimum reserved value for edges.</p> <code>0.1</code> <code>edge_reserved_value_max</code> <code>float</code> <p>Maximum reserved value for edges.</p> <code>0.4</code> <code>edge_types</code> <code>list[str | type[ANL2025Negotiator]]</code> <p>Types of edge agents</p> <code>[Boulware2025, RandomNegotiator, Shochan2025, AgentRenting2025]</code> <code>nissues</code> <code>int</code> <p>Number of issues to use for each thread.</p> <code>3</code> <code>nvalues</code> <code>int</code> <p>Number of values per issue for each thread.</p> <code>7</code> <code>nsteps</code> <code>int</code> <p>Number of negotiation steps.</p> <code>100</code> <code>keep_order</code> <code>bool</code> <p>Keep the order of edges when advancing the negotiation.</p> <code>False</code> <code>share_ufuns</code> <code>bool</code> <p>If given, agents will have access to partner ufuns through <code>self.opponent_ufun</code>.</p> <code>False</code> <code>atomic</code> <code>bool</code> <p>If given, one step corresponds to one offer instead of a full round.</p> <code>False</code> <code>output</code> <code>Path | None</code> <p>Folder to store the logs and results within.</p> <code>home() / 'negmas' / 'anl2025' / 'session'</code> <code>name</code> <code>str</code> <p>Name of the session</p> <code>''</code> <code>dry</code> <code>bool</code> <p>IF true, nothing will be run.</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>Print progress</p> <code>False</code> <p>Returns:</p> Type Description <code>SessionResults</code> <p><code>SessionResults</code> giving the results of the multideal negotiation session.</p> Source code in <code>anl2025/runner.py</code> <pre><code>def run_generated_session(\n    # center\n    center_type: str = \"Boulware2025\",\n    center_params: dict[str, Any] | None = None,\n    center_reserved_value_min: float = 0.0,\n    center_reserved_value_max: float = 0.0,\n    center_ufun_type: str | type[CenterUFun] = \"MaxCenterUFun\",\n    center_ufun_params: dict[str, Any] | None = None,\n    # edges\n    nedges: int = 10,\n    edge_reserved_value_min: float = 0.1,\n    edge_reserved_value_max: float = 0.4,\n    edge_types: list[str | type[ANL2025Negotiator]] = [\n        Boulware2025,\n        RandomNegotiator,\n        Shochan2025,\n        AgentRenting2025,\n    ],\n    # outcome space\n    nissues: int = 3,\n    nvalues: int = 7,\n    # mechanism params\n    nsteps: int = 100,\n    keep_order: bool = False,\n    share_ufuns: bool = False,\n    atomic: bool = False,\n    # output and logging\n    output: Path | None = Path.home() / \"negmas\" / \"anl2025\" / \"session\",\n    name: str = \"\",\n    dry: bool = True,\n    method=DEFAULT_METHOD,\n    verbose: bool = False,\n) -&gt; SessionResults:\n    \"\"\"Generates a multideal negotiation session and runs it.\n\n    Args:\n        method: the method to use for running all the sessions.\n                Acceptable options are: sequential, ordered, threads, processes.\n                See `negmas.mechanisms.Mechanism.run_all()` for full details.\n        center_type: Type of the center agent\n        center_params: Optional parameters to pass to the center agent.\n        center_reserved_value_min: Minimum reserved value for the center agent.\n        center_reserved_value_max: Maximum reserved value for the center agent.\n        center_ufun_type: Type of the center agent ufun.\n        center_ufun_params: Parameters to pass to the center agent ufun.\n        nedges: Number of edges.\n        edge_reserved_value_min: Minimum reserved value for edges.\n        edge_reserved_value_max: Maximum reserved value for edges.\n        edge_types: Types of edge agents\n        nissues: Number of issues to use for each thread.\n        nvalues: Number of values per issue for each thread.\n        nsteps: Number of negotiation steps.\n        keep_order: Keep the order of edges when advancing the negotiation.\n        share_ufuns: If given, agents will have access to partner ufuns through `self.opponent_ufun`.\n        atomic: If given, one step corresponds to one offer instead of a full round.\n        output: Folder to store the logs and results within.\n        name: Name of the session\n        dry: IF true, nothing will be run.\n        verbose: Print progress\n\n    Returns:\n        `SessionResults` giving the results of the multideal negotiation session.\n    \"\"\"\n    sample_edges = nedges &gt; 0\n    if not sample_edges:\n        nedges = len(edge_types)\n    scenario = make_multideal_scenario(\n        nedges=nedges,\n        nissues=nissues,\n        nvalues=nvalues,\n        center_reserved_value_min=center_reserved_value_min,\n        center_reserved_value_max=center_reserved_value_max,\n        center_ufun_type=center_ufun_type,\n        center_ufun_params=center_ufun_params,\n        edge_reserved_value_min=edge_reserved_value_min,\n        edge_reserved_value_max=edge_reserved_value_max,\n    )\n    run_params = RunParams(\n        nsteps=nsteps,\n        keep_order=keep_order,\n        share_ufuns=share_ufuns,\n        atomic=atomic,\n        method=method,\n    )\n    assigned = assign_scenario(\n        scenario=scenario,\n        run_params=run_params,\n        center_type=center_type,\n        center_params=center_params,\n        edge_types=edge_types,\n        verbose=verbose,\n        sample_edges=sample_edges,\n    )\n    return assigned.run(output=output, name=name, dry=dry, verbose=verbose)\n</code></pre>"},{"location":"reference/#anl2025.runner.RunParams","title":"<code>anl2025.runner.RunParams</code>","text":"<p>Defines the running parameters of the multi-deal negotiation like time-limits.</p> <p>Attributes:</p> Name Type Description <code>nsteps</code> <code>int</code> <p>Number of negotiation steps</p> <code>keep_order</code> <code>bool</code> <p>Keep the order of  negotiation threads when scheduling next action</p> <code>share_ufuns</code> <code>bool</code> <p>If given, agents can access partner ufuns through <code>self.opponeng_ufun</code></p> <code>atomic</code> <code>bool</code> <p>Every step is a single offer (if not given, on the other hand, every step is a complete round)</p> <code>method</code> <code>str</code> <p>the method to use for running all the sessions.  Acceptable options are: sequential,     ordered, threads, processes. See <code>negmas.mechanisms.Mechanism.run_all()</code> for full details</p> Source code in <code>anl2025/common.py</code> <pre><code>@define\nclass RunParams:\n    \"\"\"Defines the running parameters of the multi-deal negotiation like time-limits.\n\n    Attributes:\n        nsteps: Number of negotiation steps\n        keep_order: Keep the order of  negotiation threads when scheduling next action\n        share_ufuns: If given, agents can access partner ufuns through `self.opponeng_ufun`\n        atomic: Every step is a single offer (if not given, on the other hand, every step is a complete round)\n        method: the method to use for running all the sessions.  Acceptable options are: sequential,\n                ordered, threads, processes. See `negmas.mechanisms.Mechanism.run_all()` for full details\n    \"\"\"\n\n    # mechanism params\n    nsteps: int = 100\n    keep_order: bool = False\n    share_ufuns: bool = False\n    atomic: bool = False\n    method: str = DEFAULT_METHOD\n</code></pre>"},{"location":"reference/#anl2025.runner.SessionResults","title":"<code>anl2025.runner.SessionResults</code>","text":"<p>Results of a single multideal negotiation</p> <p>Attributes:</p> Name Type Description <code>mechanisms</code> <code>list[SAOMechanism]</code> <p>The mechanisms representing negotiation threads.</p> <code>center</code> <code>ANL2025Negotiator</code> <p>The center agent</p> <code>edges</code> <code>list[ANL2025Negotiator]</code> <p>Edge agents</p> <code>agreements</code> <code>list[Outcome | None]</code> <p>Negotiation outcomes for all threads.</p> <code>center_utility</code> <code>float</code> <p>The utility received by the center.</p> <code>edge_utilities</code> <code>list[float]</code> <p>The utilities of all edges.</p> Source code in <code>anl2025/runner.py</code> <pre><code>@define\nclass SessionResults:\n    \"\"\"Results of a single multideal negotiation\n\n    Attributes:\n        mechanisms: The mechanisms representing negotiation threads.\n        center: The center agent\n        edges: Edge agents\n        agreements:  Negotiation outcomes for all threads.\n        center_utility: The utility received by the center.\n        edge_utilities: The utilities of all edges.\n    \"\"\"\n\n    mechanisms: list[SAOMechanism]\n    center: ANL2025Negotiator\n    edges: list[ANL2025Negotiator]\n    agreements: list[Outcome | None]\n    center_utility: float\n    edge_utilities: list[float]\n</code></pre>"},{"location":"reference/#tournaments","title":"Tournaments","text":""},{"location":"reference/#anl2025.tournament.Tournament","title":"<code>anl2025.tournament.Tournament</code>","text":"<p>Represents a tournament</p> <p>Attributes:</p> Name Type Description <code>competitors</code> <code>tuple[str | type[ANL2025Negotiator], ...]</code> <p>the competing agents of type <code>ANL2025Negotiator</code> each</p> <code>scenarios</code> <code>tuple[MultidealScenario, ...]</code> <p>the scenarios in which the competitors are tested</p> <code>run_params</code> <code>RunParams</code> <p>parameters controlling the tournament run (See <code>RunParams</code>)</p> <code>competitor_params</code> <code>tuple[dict[str, Any] | None, ...] | None</code> <p>Parameters to pass to the competitors</p> <p>Methods:</p> Name Description <code>from_scenarios</code> <p>Loads a tournament from the given scenarios (optionally generating new ones)</p> <code>load</code> <p>Loads the tournament information.</p> <code>run</code> <p>Run the tournament</p> <code>save</code> <p>Saves the tournament information.</p> Source code in <code>anl2025/tournament.py</code> <pre><code>@define\nclass Tournament:\n    \"\"\"Represents a tournament\n\n    Attributes:\n        competitors: the competing agents of type `ANL2025Negotiator` each\n        scenarios: the scenarios in which the competitors are tested\n        run_params: parameters controlling the tournament run (See `RunParams`)\n        competitor_params: Parameters to pass to the competitors\n    \"\"\"\n\n    competitors: tuple[str | type[ANL2025Negotiator], ...]\n    scenarios: tuple[MultidealScenario, ...]\n    run_params: RunParams\n    competitor_params: tuple[dict[str, Any] | None, ...] | None = None\n\n    @classmethod\n    def from_scenarios(\n        cls,\n        competitors: Sequence[str | type[ANL2025Negotiator]],\n        run_params: RunParams,\n        scenarios: tuple[MultidealScenario, ...] = tuple(),\n        n_generated: int = 0,\n        nedges: int = 3,\n        nissues: int = 3,\n        nvalues: int = 7,\n        # edge ufuns\n        center_reserved_value_min: float = 0.0,\n        center_reserved_value_max: float = 0.0,\n        center_ufun_type: str | type[CenterUFun] = \"MaxCenterUFun\",\n        center_ufun_params: dict[str, Any] | None = None,\n        # edge ufuns\n        edge_reserved_value_min: float = 0.1,\n        edge_reserved_value_max: float = 0.4,\n        competitor_params: tuple[dict[str, Any] | None, ...] | None = None,\n    ) -&gt; Self:\n        \"\"\"Loads a tournament from the given scenarios (optionally generating new ones)\n\n        Args:\n            competitors: Competing agents\n            run_params: `RunParams` controlling the timing of each multideal negotiation\n            scenarios: An optional tuple of predefined scenarios (`MultidealScenario`)\n            n_generated: Number of new scenarios to generate\n            nedges: Number of negotiation threads (only used if `n_generated` &gt; 0)\n            nissues:Number of negotiation issues per thread (only used if `n_generated` &gt; 0)\n            nvalues: Number of values per issue (only used if `n_generated` &gt; 0)\n            center_reserved_value_min: Minimum reserved value of the center for generated scenarios.\n            center_reserved_value_max: Maximum reserved value of the center for generated scenarios.\n            center_ufun_type: center agent ufun for generated scenarios.\n            center_ufun_params: center agent ufun params for generated scenarios.\n            edge_reserved_value_min: Minimum reserved value of  edges for generated scenarios.\n            edge_reserved_value_max: Maximum reserved value of  edges for generated scenarios.\n            competitor_params: Optional competitor paramters\n\n        Returns:\n            A `Tournament` ready to run\n        \"\"\"\n        if nedges &gt; len(competitors):\n            raise ValueError(\n                f\"We have {len(competitors)} competitors which is not enough for {nedges} edges\"\n            )\n        return cls(\n            competitors=tuple(competitors),\n            competitor_params=competitor_params,\n            run_params=run_params,\n            scenarios=tuple(\n                list(scenarios)\n                + [\n                    make_multideal_scenario(\n                        nedges=nedges,\n                        nissues=nissues,\n                        nvalues=nvalues,\n                        center_reserved_value_min=center_reserved_value_min,\n                        center_reserved_value_max=center_reserved_value_max,\n                        center_ufun_type=center_ufun_type,\n                        center_ufun_params=center_ufun_params,\n                        edge_reserved_value_min=edge_reserved_value_min,\n                        edge_reserved_value_max=edge_reserved_value_max,\n                    )\n                    for _ in range(n_generated)\n                ]\n            ),\n        )\n\n    def __attrs_post_init__(self):\n        if not self.competitor_params:\n            self.competitor_params = tuple(dict() for _ in range(len(self.competitors)))\n        self.competitor_params = tuple(\n            dict() if not _ else _ for _ in self.competitor_params\n        )\n\n    def save(\n        self,\n        path: Path,\n        separate_scenarios: bool = False,\n        python_class_identifier=TYPE_IDENTIFIER,\n    ):\n        \"\"\"\n        Saves the tournament information.\n\n        Args:\n            path: A file to save information about the tournament to\n            separate_scenarios: If `True`, scenarios will be saved inside a `scenarios` folder beside the path given otherwise they will be included in the file\n        \"\"\"\n        data = dict(\n            competitors=[get_full_type_name(_) for _ in self.competitors],\n            run_params=asdict(self.run_params),\n            competitor_params=None\n            if not self.competitor_params\n            else [\n                serialize(_, python_class_identifier=python_class_identifier)\n                for _ in self.competitor_params\n            ],\n        )\n        if separate_scenarios:\n            base = path.resolve().parent / \"scenarios\"\n            for i, s in enumerate(self.scenarios):\n                name = s.name if s.name else f\"s{i:03}\"\n                dst = base\n                dst.mkdir(parents=True, exist_ok=True)\n                dump(\n                    serialize(s, python_class_identifier=python_class_identifier),\n                    dst / f\"{name}.yaml\",\n                )\n        else:\n            data[\"scenarios\"] = [\n                serialize(_, python_class_identifier=python_class_identifier)\n                for _ in self.scenarios\n            ]\n        dump(data, path)\n\n    @classmethod\n    def load(cls, path: Path, python_class_identifier=TYPE_IDENTIFIER):\n        \"\"\"Loads the tournament information.\"\"\"\n        info = load(path)\n        base = path.resolve().parent / \"scenarios\"\n        if \"scenarios\" not in info:\n            info[\"scenarios\"] = []\n        else:\n            info[\"scenarios\"] = list(info[\"scenarios\"])\n\n        if base.exists():\n            info[\"scenarios\"] += [\n                deserialize(f, python_class_identifier=python_class_identifier)\n                for f in base.glob(\"*.yaml\")\n            ]\n\n        return cls(\n            competitors=info[\"competitors\"],\n            scenarios=[\n                deserialize(_, python_class_identifier=python_class_identifier)\n                for _ in info[\"scenarios\"]\n            ],  # type: ignore\n            run_params=RunParams(**info[\"run_params\"]),\n            competitor_params=None  # type: ignore\n            if not info.get(\"competitor_params\", None)\n            else deserialize(\n                info[\"competitor_params\"],\n                python_class_identifier=python_class_identifier,\n            ),\n        )\n\n    def run(\n        self,\n        n_repetitions: int,\n        path: Path | None = None,\n        verbose: bool = False,\n        dry: bool = False,\n        no_double_scores: bool = True,\n        non_comptitor_types: tuple[str | type[ANL2025Negotiator], ...] | None = None,\n        non_comptitor_params: tuple[dict[str, Any], ...] | None = None,\n        n_jobs: int | float | None = 0,\n        center_multiplier: float | None = None,\n        edge_multiplier: float = 1,\n    ) -&gt; TournamentResults:\n        \"\"\"Run the tournament\n\n        Args:\n            n_repetitions: Number of repetitions of rotations over scenarios\n            path: Path to save the results to\n            verbose: Print progress\n            dry: Do not really run the negotiations.\n            no_double_scores: Avoid having the same agent in multiple positions in the same negotiation\n            non_comptitor_types: Types to use to fill missing edge locations if not enough competitors are available\n            non_comptitor_params: Paramters of non-competitor-types\n            n_jobs: Number of parallel jobs to use.\n                    None (and negative numbers) mean serially, 0 means use all cores, fractions mean fraction of available\n                    cores, integers mean exact number of cores\n            center_multiplier: A number to multiply center utilities with before calculating the score. Can be used\n                               to give more or less value to being a center. If None, it will be equal to the number of edges.\n            edge_multiplier: A number to multiply edge utilities with before calculating the score. Can be used\n                               to give more or less value to being an edge\n\n        Returns:\n            `TournamentResults` with all scores and final-scores\n        \"\"\"\n        if n_jobs is not None:\n            if isinstance(n_jobs, float) and n_jobs &lt; 1.0:\n                n_jobs = int(0.5 + cpu_count() * n_jobs)\n            elif isinstance(n_jobs, float):\n                n_jobs = int(0.5 + n_jobs)\n            if n_jobs &lt; 0:\n                n_jobs = None\n            elif n_jobs == 0:\n                n_jobs = cpu_count()\n\n        results = []\n        assert isinstance(self.competitor_params, tuple)\n        final_scores = defaultdict(float)\n        scores = []\n        center_multiplier_val = center_multiplier\n\n        def type_name(x):\n            return get_full_type_name(x).replace(\"anl2025.negotiator.\", \"\")\n\n        if non_comptitor_types:\n            non_comptitor_types = tuple(get_class(_) for _ in non_comptitor_types)\n            non_comptitor_params = (\n                non_comptitor_params\n                if non_comptitor_params\n                else tuple(dict() for _ in range(len(non_comptitor_types)))\n            )\n            non_competitors = [\n                (n, p)\n                for n, p in zip(non_comptitor_types, non_comptitor_params, strict=True)\n            ]\n        else:\n            non_competitors = None\n\n        jobs = []\n        for i in track(range(n_repetitions), \"Preparing Negotiation Sessions\"):\n            competitors = [\n                (get_class(c), p)\n                for c, p in zip(self.competitors, self.competitor_params, strict=True)\n            ]\n            for k, scenario in enumerate(self.scenarios):\n                nedges = len(scenario.edge_ufuns)\n                sname = scenario.name if scenario.name else f\"s{k:03}\"\n                random.shuffle(competitors)\n                for j in range(len(competitors)):\n                    if len(competitors) &gt;= nedges + 1:\n                        players = competitors[: nedges + 1]\n                    else:\n                        # add extra players at the end if not enough competitors are available\n                        players = competitors + list(\n                            random.choices(\n                                non_competitors if non_competitors else competitors,\n                                k=nedges + 1 - len(competitors),\n                            )\n                        )\n                    # ignore the randomly added edges if no-double-scores is set\n                    nedges_counted = (\n                        nedges\n                        if not no_double_scores\n                        else min(len(competitors) - 1, nedges)\n                    )\n                    if path:\n                        output = path / \"results\" / sname / f\"r{j:03}t{i:03}\"\n                    else:\n                        output = None\n                    center, center_params = players[j]\n                    edge_info = [_ for _ in players[:j] + players[j + 1 :]]\n                    # not sure if the following shuffle is useful!\n                    # It tries to randomize the order of the edges to avoid\n                    # having a systematic bias but we randomize competitors anyway.\n                    random.shuffle(edge_info)\n                    edges = [_[0] for _ in edge_info]\n                    edge_params = [_[1] if _[1] else dict() for _ in edge_info]\n                    assigned = assign_scenario(\n                        scenario=scenario,\n                        run_params=self.run_params,\n                        center_type=center,\n                        center_params=center_params,\n                        edge_types=edges,  # type: ignore\n                        edge_params=edge_params,\n                        verbose=verbose,\n                        sample_edges=False,\n                    )\n                    jobs.append(\n                        JobInfo(\n                            assigned,\n                            output,\n                            sname,\n                            i,\n                            j,\n                            k,\n                            center,\n                            center_params,\n                            edges,\n                            edge_params,\n                            edge_info,\n                            nedges_counted,\n                        )\n                    )\n            # This rotation guarantees that every competitor is\n            # the center once per scenario per repetition\n            competitors = [competitors[-1]] + competitors[:-1]\n        if verbose:\n            print(f\"Will run {len(jobs)} negotiations\")\n\n        def process_info(job: JobInfo, info: SessionInfo):\n            center_multiplier = (\n                center_multiplier_val\n                if center_multiplier_val is not None\n                else len(job.edge_info)\n            )\n            r = info.results\n            results.append(info)\n            center, center_params = job.center, job.center_params\n            cname = (\n                type_name(center)\n                if not center_params\n                else f\"{type_name(center)}_{hash(str(center_params))}\"\n            )\n            mean_edge_utility = sum(r.edge_utilities) / len(r.edge_utilities)\n            scores.append(\n                dict(\n                    agent=cname,\n                    utility=r.center_utility * center_multiplier,\n                    partner_average_utility=mean_edge_utility,\n                    scenario=job.sname,\n                    repetition=job.rep_index,\n                    rotation=job.competitor_index,\n                    scenario_index=job.scenario_index,\n                    index=0,\n                )\n            )\n            final_scores[cname] += r.center_utility\n            for e, (c, p) in enumerate(job.edge_info[: job.nedges_counted]):\n                cname = type_name(c) if not p else f\"{type_name(c)}_{hash(str(p))}\"\n                scores.append(\n                    dict(\n                        agent=cname,\n                        utility=r.edge_utilities[e] * edge_multiplier,\n                        partner_average_utility=r.center_utility,\n                        scenario=job.sname,\n                        repetition=job.rep_index,\n                        rotation=job.competitor_index,\n                        scenario_index=job.scenario_index,\n                        index=e + 1,\n                    )\n                )\n                final_scores[cname] += r.edge_utilities[e]\n            if verbose:\n                print(f\"Center Utility: {r.center_utility}\")\n                print(f\"Edge Utilities: {r.edge_utilities}\")\n\n        if n_jobs is None:\n            for job in track(jobs, \"Running Negotiations\"):\n                job, info = run_session(job, dry, verbose)\n                process_info(job, info)\n        else:\n            assert n_jobs &gt; 0\n            with ProcessPoolExecutor(max_workers=n_jobs) as executor:\n                # Submit all jobs and store the futures\n                futures = [\n                    executor.submit(run_session, job, dry, verbose) for job in jobs\n                ]\n\n                # Process results as they become available\n                for future in as_completed(futures):\n                    try:\n                        job, info = future.result()\n                        process_info(job, info)\n                    except Exception as e:\n                        print(f\"Job failed with exception: {e}\")\n\n        return TournamentResults(\n            final_scores={k: v for k, v in final_scores.items()},\n            scores=scores,\n            session_results=results,\n        )\n</code></pre>"},{"location":"reference/#anl2025.tournament.Tournament.from_scenarios","title":"<code>from_scenarios</code>  <code>classmethod</code>","text":"<p>Loads a tournament from the given scenarios (optionally generating new ones)</p> <p>Parameters:</p> Name Type Description Default <code>competitors</code> <code>Sequence[str | type[ANL2025Negotiator]]</code> <p>Competing agents</p> required <code>run_params</code> <code>RunParams</code> <p><code>RunParams</code> controlling the timing of each multideal negotiation</p> required <code>scenarios</code> <code>tuple[MultidealScenario, ...]</code> <p>An optional tuple of predefined scenarios (<code>MultidealScenario</code>)</p> <code>tuple()</code> <code>n_generated</code> <code>int</code> <p>Number of new scenarios to generate</p> <code>0</code> <code>nedges</code> <code>int</code> <p>Number of negotiation threads (only used if <code>n_generated</code> &gt; 0)</p> <code>3</code> <code>nissues</code> <code>int</code> <p>Number of negotiation issues per thread (only used if <code>n_generated</code> &gt; 0)</p> <code>3</code> <code>nvalues</code> <code>int</code> <p>Number of values per issue (only used if <code>n_generated</code> &gt; 0)</p> <code>7</code> <code>center_reserved_value_min</code> <code>float</code> <p>Minimum reserved value of the center for generated scenarios.</p> <code>0.0</code> <code>center_reserved_value_max</code> <code>float</code> <p>Maximum reserved value of the center for generated scenarios.</p> <code>0.0</code> <code>center_ufun_type</code> <code>str | type[CenterUFun]</code> <p>center agent ufun for generated scenarios.</p> <code>'MaxCenterUFun'</code> <code>center_ufun_params</code> <code>dict[str, Any] | None</code> <p>center agent ufun params for generated scenarios.</p> <code>None</code> <code>edge_reserved_value_min</code> <code>float</code> <p>Minimum reserved value of  edges for generated scenarios.</p> <code>0.1</code> <code>edge_reserved_value_max</code> <code>float</code> <p>Maximum reserved value of  edges for generated scenarios.</p> <code>0.4</code> <code>competitor_params</code> <code>tuple[dict[str, Any] | None, ...] | None</code> <p>Optional competitor paramters</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>A <code>Tournament</code> ready to run</p> Source code in <code>anl2025/tournament.py</code> <pre><code>@classmethod\ndef from_scenarios(\n    cls,\n    competitors: Sequence[str | type[ANL2025Negotiator]],\n    run_params: RunParams,\n    scenarios: tuple[MultidealScenario, ...] = tuple(),\n    n_generated: int = 0,\n    nedges: int = 3,\n    nissues: int = 3,\n    nvalues: int = 7,\n    # edge ufuns\n    center_reserved_value_min: float = 0.0,\n    center_reserved_value_max: float = 0.0,\n    center_ufun_type: str | type[CenterUFun] = \"MaxCenterUFun\",\n    center_ufun_params: dict[str, Any] | None = None,\n    # edge ufuns\n    edge_reserved_value_min: float = 0.1,\n    edge_reserved_value_max: float = 0.4,\n    competitor_params: tuple[dict[str, Any] | None, ...] | None = None,\n) -&gt; Self:\n    \"\"\"Loads a tournament from the given scenarios (optionally generating new ones)\n\n    Args:\n        competitors: Competing agents\n        run_params: `RunParams` controlling the timing of each multideal negotiation\n        scenarios: An optional tuple of predefined scenarios (`MultidealScenario`)\n        n_generated: Number of new scenarios to generate\n        nedges: Number of negotiation threads (only used if `n_generated` &gt; 0)\n        nissues:Number of negotiation issues per thread (only used if `n_generated` &gt; 0)\n        nvalues: Number of values per issue (only used if `n_generated` &gt; 0)\n        center_reserved_value_min: Minimum reserved value of the center for generated scenarios.\n        center_reserved_value_max: Maximum reserved value of the center for generated scenarios.\n        center_ufun_type: center agent ufun for generated scenarios.\n        center_ufun_params: center agent ufun params for generated scenarios.\n        edge_reserved_value_min: Minimum reserved value of  edges for generated scenarios.\n        edge_reserved_value_max: Maximum reserved value of  edges for generated scenarios.\n        competitor_params: Optional competitor paramters\n\n    Returns:\n        A `Tournament` ready to run\n    \"\"\"\n    if nedges &gt; len(competitors):\n        raise ValueError(\n            f\"We have {len(competitors)} competitors which is not enough for {nedges} edges\"\n        )\n    return cls(\n        competitors=tuple(competitors),\n        competitor_params=competitor_params,\n        run_params=run_params,\n        scenarios=tuple(\n            list(scenarios)\n            + [\n                make_multideal_scenario(\n                    nedges=nedges,\n                    nissues=nissues,\n                    nvalues=nvalues,\n                    center_reserved_value_min=center_reserved_value_min,\n                    center_reserved_value_max=center_reserved_value_max,\n                    center_ufun_type=center_ufun_type,\n                    center_ufun_params=center_ufun_params,\n                    edge_reserved_value_min=edge_reserved_value_min,\n                    edge_reserved_value_max=edge_reserved_value_max,\n                )\n                for _ in range(n_generated)\n            ]\n        ),\n    )\n</code></pre>"},{"location":"reference/#anl2025.tournament.Tournament.load","title":"<code>load</code>  <code>classmethod</code>","text":"<p>Loads the tournament information.</p> Source code in <code>anl2025/tournament.py</code> <pre><code>@classmethod\ndef load(cls, path: Path, python_class_identifier=TYPE_IDENTIFIER):\n    \"\"\"Loads the tournament information.\"\"\"\n    info = load(path)\n    base = path.resolve().parent / \"scenarios\"\n    if \"scenarios\" not in info:\n        info[\"scenarios\"] = []\n    else:\n        info[\"scenarios\"] = list(info[\"scenarios\"])\n\n    if base.exists():\n        info[\"scenarios\"] += [\n            deserialize(f, python_class_identifier=python_class_identifier)\n            for f in base.glob(\"*.yaml\")\n        ]\n\n    return cls(\n        competitors=info[\"competitors\"],\n        scenarios=[\n            deserialize(_, python_class_identifier=python_class_identifier)\n            for _ in info[\"scenarios\"]\n        ],  # type: ignore\n        run_params=RunParams(**info[\"run_params\"]),\n        competitor_params=None  # type: ignore\n        if not info.get(\"competitor_params\", None)\n        else deserialize(\n            info[\"competitor_params\"],\n            python_class_identifier=python_class_identifier,\n        ),\n    )\n</code></pre>"},{"location":"reference/#anl2025.tournament.Tournament.run","title":"<code>run</code>","text":"<p>Run the tournament</p> <p>Parameters:</p> Name Type Description Default <code>n_repetitions</code> <code>int</code> <p>Number of repetitions of rotations over scenarios</p> required <code>path</code> <code>Path | None</code> <p>Path to save the results to</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Print progress</p> <code>False</code> <code>dry</code> <code>bool</code> <p>Do not really run the negotiations.</p> <code>False</code> <code>no_double_scores</code> <code>bool</code> <p>Avoid having the same agent in multiple positions in the same negotiation</p> <code>True</code> <code>non_comptitor_types</code> <code>tuple[str | type[ANL2025Negotiator], ...] | None</code> <p>Types to use to fill missing edge locations if not enough competitors are available</p> <code>None</code> <code>non_comptitor_params</code> <code>tuple[dict[str, Any], ...] | None</code> <p>Paramters of non-competitor-types</p> <code>None</code> <code>n_jobs</code> <code>int | float | None</code> <p>Number of parallel jobs to use.     None (and negative numbers) mean serially, 0 means use all cores, fractions mean fraction of available     cores, integers mean exact number of cores</p> <code>0</code> <code>center_multiplier</code> <code>float | None</code> <p>A number to multiply center utilities with before calculating the score. Can be used                to give more or less value to being a center. If None, it will be equal to the number of edges.</p> <code>None</code> <code>edge_multiplier</code> <code>float</code> <p>A number to multiply edge utilities with before calculating the score. Can be used                to give more or less value to being an edge</p> <code>1</code> <p>Returns:</p> Type Description <code>TournamentResults</code> <p><code>TournamentResults</code> with all scores and final-scores</p> Source code in <code>anl2025/tournament.py</code> <pre><code>def run(\n    self,\n    n_repetitions: int,\n    path: Path | None = None,\n    verbose: bool = False,\n    dry: bool = False,\n    no_double_scores: bool = True,\n    non_comptitor_types: tuple[str | type[ANL2025Negotiator], ...] | None = None,\n    non_comptitor_params: tuple[dict[str, Any], ...] | None = None,\n    n_jobs: int | float | None = 0,\n    center_multiplier: float | None = None,\n    edge_multiplier: float = 1,\n) -&gt; TournamentResults:\n    \"\"\"Run the tournament\n\n    Args:\n        n_repetitions: Number of repetitions of rotations over scenarios\n        path: Path to save the results to\n        verbose: Print progress\n        dry: Do not really run the negotiations.\n        no_double_scores: Avoid having the same agent in multiple positions in the same negotiation\n        non_comptitor_types: Types to use to fill missing edge locations if not enough competitors are available\n        non_comptitor_params: Paramters of non-competitor-types\n        n_jobs: Number of parallel jobs to use.\n                None (and negative numbers) mean serially, 0 means use all cores, fractions mean fraction of available\n                cores, integers mean exact number of cores\n        center_multiplier: A number to multiply center utilities with before calculating the score. Can be used\n                           to give more or less value to being a center. If None, it will be equal to the number of edges.\n        edge_multiplier: A number to multiply edge utilities with before calculating the score. Can be used\n                           to give more or less value to being an edge\n\n    Returns:\n        `TournamentResults` with all scores and final-scores\n    \"\"\"\n    if n_jobs is not None:\n        if isinstance(n_jobs, float) and n_jobs &lt; 1.0:\n            n_jobs = int(0.5 + cpu_count() * n_jobs)\n        elif isinstance(n_jobs, float):\n            n_jobs = int(0.5 + n_jobs)\n        if n_jobs &lt; 0:\n            n_jobs = None\n        elif n_jobs == 0:\n            n_jobs = cpu_count()\n\n    results = []\n    assert isinstance(self.competitor_params, tuple)\n    final_scores = defaultdict(float)\n    scores = []\n    center_multiplier_val = center_multiplier\n\n    def type_name(x):\n        return get_full_type_name(x).replace(\"anl2025.negotiator.\", \"\")\n\n    if non_comptitor_types:\n        non_comptitor_types = tuple(get_class(_) for _ in non_comptitor_types)\n        non_comptitor_params = (\n            non_comptitor_params\n            if non_comptitor_params\n            else tuple(dict() for _ in range(len(non_comptitor_types)))\n        )\n        non_competitors = [\n            (n, p)\n            for n, p in zip(non_comptitor_types, non_comptitor_params, strict=True)\n        ]\n    else:\n        non_competitors = None\n\n    jobs = []\n    for i in track(range(n_repetitions), \"Preparing Negotiation Sessions\"):\n        competitors = [\n            (get_class(c), p)\n            for c, p in zip(self.competitors, self.competitor_params, strict=True)\n        ]\n        for k, scenario in enumerate(self.scenarios):\n            nedges = len(scenario.edge_ufuns)\n            sname = scenario.name if scenario.name else f\"s{k:03}\"\n            random.shuffle(competitors)\n            for j in range(len(competitors)):\n                if len(competitors) &gt;= nedges + 1:\n                    players = competitors[: nedges + 1]\n                else:\n                    # add extra players at the end if not enough competitors are available\n                    players = competitors + list(\n                        random.choices(\n                            non_competitors if non_competitors else competitors,\n                            k=nedges + 1 - len(competitors),\n                        )\n                    )\n                # ignore the randomly added edges if no-double-scores is set\n                nedges_counted = (\n                    nedges\n                    if not no_double_scores\n                    else min(len(competitors) - 1, nedges)\n                )\n                if path:\n                    output = path / \"results\" / sname / f\"r{j:03}t{i:03}\"\n                else:\n                    output = None\n                center, center_params = players[j]\n                edge_info = [_ for _ in players[:j] + players[j + 1 :]]\n                # not sure if the following shuffle is useful!\n                # It tries to randomize the order of the edges to avoid\n                # having a systematic bias but we randomize competitors anyway.\n                random.shuffle(edge_info)\n                edges = [_[0] for _ in edge_info]\n                edge_params = [_[1] if _[1] else dict() for _ in edge_info]\n                assigned = assign_scenario(\n                    scenario=scenario,\n                    run_params=self.run_params,\n                    center_type=center,\n                    center_params=center_params,\n                    edge_types=edges,  # type: ignore\n                    edge_params=edge_params,\n                    verbose=verbose,\n                    sample_edges=False,\n                )\n                jobs.append(\n                    JobInfo(\n                        assigned,\n                        output,\n                        sname,\n                        i,\n                        j,\n                        k,\n                        center,\n                        center_params,\n                        edges,\n                        edge_params,\n                        edge_info,\n                        nedges_counted,\n                    )\n                )\n        # This rotation guarantees that every competitor is\n        # the center once per scenario per repetition\n        competitors = [competitors[-1]] + competitors[:-1]\n    if verbose:\n        print(f\"Will run {len(jobs)} negotiations\")\n\n    def process_info(job: JobInfo, info: SessionInfo):\n        center_multiplier = (\n            center_multiplier_val\n            if center_multiplier_val is not None\n            else len(job.edge_info)\n        )\n        r = info.results\n        results.append(info)\n        center, center_params = job.center, job.center_params\n        cname = (\n            type_name(center)\n            if not center_params\n            else f\"{type_name(center)}_{hash(str(center_params))}\"\n        )\n        mean_edge_utility = sum(r.edge_utilities) / len(r.edge_utilities)\n        scores.append(\n            dict(\n                agent=cname,\n                utility=r.center_utility * center_multiplier,\n                partner_average_utility=mean_edge_utility,\n                scenario=job.sname,\n                repetition=job.rep_index,\n                rotation=job.competitor_index,\n                scenario_index=job.scenario_index,\n                index=0,\n            )\n        )\n        final_scores[cname] += r.center_utility\n        for e, (c, p) in enumerate(job.edge_info[: job.nedges_counted]):\n            cname = type_name(c) if not p else f\"{type_name(c)}_{hash(str(p))}\"\n            scores.append(\n                dict(\n                    agent=cname,\n                    utility=r.edge_utilities[e] * edge_multiplier,\n                    partner_average_utility=r.center_utility,\n                    scenario=job.sname,\n                    repetition=job.rep_index,\n                    rotation=job.competitor_index,\n                    scenario_index=job.scenario_index,\n                    index=e + 1,\n                )\n            )\n            final_scores[cname] += r.edge_utilities[e]\n        if verbose:\n            print(f\"Center Utility: {r.center_utility}\")\n            print(f\"Edge Utilities: {r.edge_utilities}\")\n\n    if n_jobs is None:\n        for job in track(jobs, \"Running Negotiations\"):\n            job, info = run_session(job, dry, verbose)\n            process_info(job, info)\n    else:\n        assert n_jobs &gt; 0\n        with ProcessPoolExecutor(max_workers=n_jobs) as executor:\n            # Submit all jobs and store the futures\n            futures = [\n                executor.submit(run_session, job, dry, verbose) for job in jobs\n            ]\n\n            # Process results as they become available\n            for future in as_completed(futures):\n                try:\n                    job, info = future.result()\n                    process_info(job, info)\n                except Exception as e:\n                    print(f\"Job failed with exception: {e}\")\n\n    return TournamentResults(\n        final_scores={k: v for k, v in final_scores.items()},\n        scores=scores,\n        session_results=results,\n    )\n</code></pre>"},{"location":"reference/#anl2025.tournament.Tournament.save","title":"<code>save</code>","text":"<p>Saves the tournament information.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>A file to save information about the tournament to</p> required <code>separate_scenarios</code> <code>bool</code> <p>If <code>True</code>, scenarios will be saved inside a <code>scenarios</code> folder beside the path given otherwise they will be included in the file</p> <code>False</code> Source code in <code>anl2025/tournament.py</code> <pre><code>def save(\n    self,\n    path: Path,\n    separate_scenarios: bool = False,\n    python_class_identifier=TYPE_IDENTIFIER,\n):\n    \"\"\"\n    Saves the tournament information.\n\n    Args:\n        path: A file to save information about the tournament to\n        separate_scenarios: If `True`, scenarios will be saved inside a `scenarios` folder beside the path given otherwise they will be included in the file\n    \"\"\"\n    data = dict(\n        competitors=[get_full_type_name(_) for _ in self.competitors],\n        run_params=asdict(self.run_params),\n        competitor_params=None\n        if not self.competitor_params\n        else [\n            serialize(_, python_class_identifier=python_class_identifier)\n            for _ in self.competitor_params\n        ],\n    )\n    if separate_scenarios:\n        base = path.resolve().parent / \"scenarios\"\n        for i, s in enumerate(self.scenarios):\n            name = s.name if s.name else f\"s{i:03}\"\n            dst = base\n            dst.mkdir(parents=True, exist_ok=True)\n            dump(\n                serialize(s, python_class_identifier=python_class_identifier),\n                dst / f\"{name}.yaml\",\n            )\n    else:\n        data[\"scenarios\"] = [\n            serialize(_, python_class_identifier=python_class_identifier)\n            for _ in self.scenarios\n        ]\n    dump(data, path)\n</code></pre>"},{"location":"tutorials/04.ideas/","title":"04.ideas","text":""},{"location":"tutorials/04.ideas/#ideas-for-developing-your-agent","title":"Ideas for developing your agent","text":"<p>This section of the tutorials will discuss some possible ideas for developing your agent. It is completely optional to read this but it may provide some directions that help you in your quest. We will assume that you are using the component based approach discussed in the second tutorial.</p> <p>Let\u2019s start by reminding ourselves of the agent decomposition used by built in agents (check this <code>video &lt;https://youtu.be/3xwR-aPZSb0&gt;</code>__ explains the main components in details).</p> <p>The three main components of an agent in this decomposition are the trading strategy, negotiation control strategy and production strategy.</p> <p>.. image:: anatomy.png</p> <p>The trading strategy decides what should the agent buy and sell (the trading schedule) and the negotiation control strategy takes that as input and uses it to drive negotiations in order to carry out this plan. The production strategy controls the factory by deciding how many items to produce at every time step (based on existing inventory and the trading schedule).</p> <p>We will discuss ideas for improving each one of these three components separately.</p> <p>Before diving into these ideas, it is important to note that the overall performance of the agent does not come from having one perfect component but from harmony between all the components constituting it. For example, a trading strategy that generates a perfect trading schedule is useless without a negotiation control strategy capable of achieving that schedule.</p> <p>Trading Strategy ~~~~~~~~~~~~~~~~</p> <p>Representing the planning department of a company, the trading strategy seems like the obvious target of improvement. This figure shows the outputs of the trading strategy and the three examples implemented in the <code>scml</code> package.</p> <p>.. image:: trading.png</p> <p>The best trading strategy used by the built-in agents is the <code>PredictionBasedTradingStrategy</code> and we will focus on it as it seems the most amenable to improvement.</p> <p>This trading strategy uses two components, a <code>TradePredictionStrategy</code> that predicts the amount of trade on the input and output products of the agent as a function of the simulation step, and an <code>ERPredictionStrategy</code> predicting the quantity that will actually be executed from a contract. These predictions are both set to constants for the built-in component. This immediately suggests the following ideas</p> <p>IDEA 1: Improve trade prediction ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</p> <p>The only <code>TradePredictionStrategy</code> implemented in <code>scml</code> is the <code>FixedTradePredictionStrategy</code> which predicts trade at a fixed amount in every product at every step (currently set to half the number of lines: :math:<code>5</code>). This can definitely be improved.</p> <ol> <li>Train a regressor (e.g.\u00a0a    <code>scikit-learn &lt;https://scikit-learn.org/stable/user_guide.html&gt;</code>    regressor) on many worlds to receive the product number and the    fraction of the simulation steps passed and predict the amount of    trade and use this regressor in real time (or store its results in a    table that you can <code>load in real    time &lt;https://scml.readthedocs.io/en/latest/faq.html#how-can-i-access-a-data-file-in-my-package&gt;</code>).</li> <li>Improve the regressor using incremental learning in real time during    world simulation. This may not be very effective in short simulations    but we will simulate up to :math:<code>200</code> steps so it may improve    performance.</li> </ol> <p>IDEA 2: Improve execution rate prediction ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</p> <p>The only <code>ERPredictionStrategy</code> implemented in the system is the <code>FixedERPredictionStrategy</code> which will expect that half of the quantity in any contract will be executed. This can easily be improved using several approaches.</p> <ol> <li>Use the financial reports of your suppliers and consumers to predict    the possibility that they will breach contracts in the future. Again    you can train a regressor that receives few past financial reports    and predicts future behavior using simulations against a variety of    agents (including your own!) and then load it in real time.</li> <li>Use more general market conditions for prediction of actual trade    amount and base your prediction of the contract execution rate on    that.</li> </ol> <p>IDEA3: Improve the logic of the trading strategy ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</p> <p>The <code>PredictionBasedTradingStrategy</code> just uses the <code>TradePredictionStrategy</code> and <code>ERPredictionStrategy</code> directly for deciding trade but that need not be the optimal thing to do. It may be possible to change that logic of the trading strategy itself to add a higher level of control over the outputs of these base prediction strategies.</p> <p>Negotiation Manager ~~~~~~~~~~~~~~~~~~~</p> <p>This is a negotiation competition and it seems fit to focus our efforts on negotiation. Moreover, as we indicated earlier, having the perfect trade schedule coming out from the trading strategy is useless for the agent if it cannot negotiate effectively to achieve that schedule.</p> <p>The negotiation control strategy consists of two main components:</p> <ul> <li>Negotiation Manager responsible of requesting negotiations as    needed and responding to such requests</li> <li>Negotiation Algorithm which can be implemented using one or more    <code>negmas</code> <code>SAOController &lt;https://negmas.readthedocs.io/en/latest/modules/sao.html?highlight=Controller#module-negmas.sao&gt;</code>    or directly using <code>negmas</code> <code>SAONegotiator &lt;https://negmas.readthedocs.io/en/latest/modules/sao.html?highlight=Negotiator#module-negmas.sao&gt;</code>.    This <code>video &lt;https://youtu.be/10Rjl3ikaDU&gt;</code>__ describes available    controllers and negotiators and of course you can - and should -    design your own.</li> </ul> <p>This figure shows the two inputs you need to define for any negotiation manager: <code>target_quantity</code> and <code>acceptable_unit_price</code>. Their names are self-descriptive.</p> <p>.. image:: negotiation.png</p> <p>Built-in negotiation managers are intentionally pretty basic. It may be that this is the point of improvement that has the highest probability of leading to winning agents (that may not be true though as the trading strategy seems as important). Here are some ideas for improving the negotiation control strategy</p> <p>IDEA 4: Improve the negotiation manager ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</p> <p>The negotiation manager responsible of starting and accepting negotiations in <code>scml</code> is extremely basic.</p> <ol> <li>It uses a target quantity that is set directly as the difference    between needs and secured quantity and it does not take into account    in any way running negotiations. You can access running negotiations    using <code>self.negotiations</code> and standing negotiation requests using    <code>self.negotiation_requests</code>.</li> <li>It always negotiates with everybody. You can use financial reports to    decide whom to negotiate with.</li> <li>It uses fixed ranges for negotiation issues. You can try to    dynamically decide the ranges allowed for negotiation issues based on    market conditions. For example, you can set the range of prices based    on your estimate of the current trading price of products.</li> </ol> <p>IDEA 5 Improve signing strategy ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</p> <p>Deciding what to sign is not strictly a part of the negotiation strategy but it needs to be implemented to respond to <code>sign_all_contracts</code>. Currently, it is handled by the trading strategy but you can override that by providing your own <code>SigningStrategy</code> that overrides <code>sign_all_contracts</code>.</p> <p>All negotiations in a single simulation step run in parallel. This means that the negotiation manager is prone to over-contracting. This can then be corrected using a <code>SigningStrategy</code> that intelligently decides what to sign.</p> <p>Negotiation Algorithm ~~~~~~~~~~~~~~~~~~~~~</p> <p>All built in negotiations are conducted using either simple negotiation algorithm (e.g.\u00a0time-based strategy, naive tit-for-tat implementation, \u2026) or a simple <code>negmas</code> built in controller. None of the adequately handles the two main challenges: concurrent negotiations within a single simulation step and taking into account future negotiation opportunities.</p> <p>IDEA 6: Improve concurrent negotiation control ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</p> <p>The <code>StepController</code> is the negotiation algorithm used by the <code>StepNegotiationManager</code> employed by the <code>DecentralizingAgent</code> (the top built-in agent). It instantiates one controller to handle buying and another to handle selling for each simulation step. These controllers rely heavily on the <code>SAOSyncController</code> of <code>negmas</code> using a time-based meta-negotiation strategy. That is a very simple algorithm that is not expected to effectively handle concurrent negotiations. Try to find a way to either coordinate the behavior of multiple autonomous negotiators each simulation step or to centrally control these negotiators to achieve the preset target.</p> <p>IDEA 7: Improve sequential negotiation control ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</p> <p>Agents in SCML negotiate repeatedly. This means that the utility of any offer in any negotiation does not only depend on current market conditions but also in expected future negotiations. Built-in agents side step the need to take that into account during negotiation by having a trading strategy and a negotiation manager set their targets for them rendering negotiations in every simulation step independent from future negotiations (given the targets). This is clearly a simplistic heuristic. Try to find a way to take future negotiations into account when designing your agent. One way to do that is to have them affect the utility function used by your controller/negotiator.</p> <p>IDEA 8: Improve the utility functions used ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</p> <p>The <code>IndependentNegotiationManager</code> uses linear independent utility functions with a simple time-base negotiation (<code>AspirationNegotiator</code>) for all of its negotiations. The other two negotiation managers employ controllers that define their utilities linearly using some built-in fixed weights for price and quantity. That is obviously suboptimal. 1. Try to improve the utility function used by either the negotiators or the controller (depending on the negotiation manager you use) to achieve higher expected utilities. 2. Try to take the identity of the agent you are negotiating with into account in your utility calculations. A contract with a trustworthy agent has more utility than one with a non-trustworthy agent. You can use the financial reports of agents to judge their trustworthiness.</p> <p>Production Strategy ~~~~~~~~~~~~~~~~~~~</p> <p>That is the simplest of the three components. There are two main production strategies in <code>scml</code> as described earlier in the second tutorial: supply based or demand based production strategies.</p> <p>IDEA 9: Base production decisions on trading prices (as well as contracts). ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</p> <p>Given that disposal cost is zero and storage capacity is infinite, it seems that the only optimization you can do is to avoid over production. Production has cost so over production may not be a good idea. On the other hand, the inventory is valued in SCML 2020 at half the trading price which means that it may be a good idea to convert inputs to outputs (even if you do not sell that output) if the difference in trading prices at the end of simulation offsets your production costs. Try creating a production strategy that takes this effect into account switching between supply based and demand based production using a estimate of the final trading prices of its input and output products.</p> <p>Final Remarks ~~~~~~~~~~~~~</p> <p>The ideas presented above are, by no means, exclusive or comprehensive. You can combine them and add new ones. The main reason we present these ideas is to challenge you to come with better ones. Happy coding :-) Download Notebook</p>"},{"location":"tutorials/Tutorial_run_a_negotiation/","title":"Running a negotiation","text":"<p>NegMAS has several built-in negotiation <code>Mechanisms</code>, negotiation agents (<code>Negotiators</code>), and <code>UtilityFunctions</code>. You can use these to run negotiations as follows.</p> <p>Imagine a buyer and a seller negotiating over the price of a single object. First, we make an issue \"price\" with 50 discrete values. Note here, it is possible to create multiple issues, but we will not include that here. If you are interested, see the NegMAS documentation for a tutorial.</p> <pre><code>from negmas import (\n    make_issue,\n    SAOMechanism,\n   TimeBasedConcedingNegotiator,\n)\nfrom anl.anl2024.negotiators import Boulware, Conceder, RVFitter\nfrom negmas.preferences import LinearAdditiveUtilityFunction as UFun\nfrom negmas.preferences.value_fun import IdentityFun, AffineFun\nimport matplotlib.pyplot as plt\n\n\n# create negotiation agenda (issues)\nissues = [\n    make_issue(name=\"price\", values=50),\n]\n\n# create the mechanism\nsession = SAOMechanism(issues=issues, n_steps=20)\n</code></pre> <p>The negotiation protocol in NegMAS is handled by a <code>Mechanism</code> object. Here we instantiate a<code>SAOMechanism</code> which implements the Stacked Alternating Offers Protocol. In this protocol, negotiators exchange offers until an offer is accepted by all negotiators (in this case 2), a negotiators leaves the table ending the negotiation or a time-out condition is met. In the example above, we use a limit on the number of rounds of <code>20</code> (a step of a mechanism is an executed round).</p> <p>Next, we define the utilities of the seller and the buyer. The utility function of the seller is defined by the <code>IdentityFun</code>  which means that the higher the price, the higher the utility function. The buyer's utility function is reversed. The last two lines make sure that utility is scaled between 0 and 1.</p> <pre><code>seller_utility = UFun(\n    values=[IdentityFun()],\n    outcome_space=session.outcome_space,\n)\n\nbuyer_utility = UFun(\n    values=[AffineFun(slope=-1)],\n    outcome_space=session.outcome_space,\n)\n\nseller_utility = seller_utility.normalize()\nbuyer_utility = buyer_utility.normalize()\n</code></pre> <p>Then we add two agents with a boulware strategy. The negotiation ends with status overview. For example, you can see if the negotiation timed-out, what agreement was found, and how long the negotiation took. Moreover, we output the full negotiation history. For a more visual representation, we can plot the session. This shows the bidding curve, but also the proximity to e.g. the Nash point.</p> <pre><code># create and add agent A and B\nsession.add(Boulware(name=\"seller\"), ufun=seller_utility)\nsession.add(Boulware(name=\"buyer\"), ufun=buyer_utility)\n\n# run the negotiation and show the results\nprint(session.run())\n\n# negotiation history\nfor i, _ in enumerate(session.history):\n    print(f\"{i:03}: {_.new_offers}\")  # the first line gives the offer of the seller and the buyer  in the first round\n\nsession.plot(ylimits=(0.0, 1.01), show_reserved=False, mark_max_welfare_points=False)\nplt.show()\n</code></pre> <pre>SAOState(\n    running=False,\n    waiting=False,\n    started=True,\n    step=18,\n    time=0.006180799915455282,\n    relative_time=0.9047619047619048,\n    broken=False,\n    timedout=False,\n    agreement=(23,),\n    results=None,\n    n_negotiators=2,\n    has_error=False,\n    error_details='',\n    threads={},\n    last_thread='',\n    current_offer=(23,),\n    current_proposer='seller-69622b52-7474-4027-bdda-e2928ad686cf',\n    current_proposer_agent=None,\n    n_acceptances=2,\n    new_offers=[('seller-69622b52-7474-4027-bdda-e2928ad686cf', (23,))],\n    new_offerer_agents=[None],\n    last_negotiator='seller'\n)\n</pre> <p></p> <p>Download Notebook</p>"},{"location":"tutorials/tutorial_develop/","title":"ANL 2024 Tutorial","text":""},{"location":"tutorials/tutorial_develop/#developing-a-negotiator","title":"Developing a negotiator","text":"<p>The agents for the ANL competition are standard NegMAS negotiators. As such, they can be developed using any approach used to develop negotiators in NegMAS.</p> <p>To develop a negotiator, you need to inherit from the SAONegotiator class and implement the <code>__call__()</code> method.</p> <p>Here is a simple random negotiator:</p> <pre><code>import random\nfrom negmas.sao import SAONegotiator, SAOResponse\nfrom negmas import Outcome, ResponseType\nclass MyRandomNegotiator(SAONegotiator):\n    def __call__(self, state):\n        offer = state.current_offer\n        if offer is not None and self.ufun.is_not_worse(offer, None) and random.random() &lt; 0.25 :\n            return SAOResponse(ResponseType.ACCEPT_OFFER, offer)\n        return SAOResponse(ResponseType.REJECT_OFFER, self.nmi.random_outcomes(1)[0])\n</code></pre>"},{"location":"tutorials/tutorial_develop/#testing-the-agent","title":"Testing the agent","text":"<pre><code>from anl.anl2024 import anl2024_tournament\nfrom anl.anl2024.negotiators import Boulware, Conceder, RVFitter\n</code></pre> <pre><code>results = anl2024_tournament(\n    n_scenarios=1, n_repetitions=3, nologs=True, njobs=-1,\n    competitors=[MyRandomNegotiator, Boulware]\n)\n</code></pre> <pre>Will run 12 negotiations on 1 scenarios between 2 competitors\n</pre> <pre><code>Output()\n</code></pre> <pre></pre> <pre>\n</pre> <pre>             strategy     score\n0            Boulware  0.767437\n1  MyRandomNegotiator  0.262742\n</pre> <p>The score that is printed is the average advantage, which is the received utility minus the reservation value. We can immediately notice that <code>MyRandomNegotiator</code> is getting a negative average advantage which means that it sometimes gets agreements that are worse than disagreement (i.e. with utility less than its reservation value). Can you guess why is this happening? How can we resolve that?</p> <p>You can easily check the final scores using the <code>final_scores</code> member of the returned SimpleTournamentResults object.</p> <pre><code>results.final_scores\n</code></pre> strategy score 0 Boulware 0.767437 1 MyRandomNegotiator 0.262742 <p>The returned results are all pandas dataframes. We can use standard pandas functions to get deeper understanding of the results. Here is how to plot a KDE figure (kind of histogram) comparing different strategies in this tournament. The higher the line, the more often this value of the advantage is observed.</p> <pre><code>fig, ax = plt.subplots(figsize=(8,6))\ndf = results.scores\nfor label, data in df.groupby('strategy'):\n    data.advantage.plot(kind=\"kde\", ax=ax, label=label)\nplt.ylabel(\"advantage\")\nplt.legend();\n</code></pre> <p></p> <pre><code>fig, axs = plt.subplots(1, 3, figsize=(16,4))\nfor i, col in enumerate([\"advantage\", \"welfare\", \"nash_optimality\"]):\n    results.scores.groupby(\"strategy\")[col].mean().sort_index().plot(kind=\"bar\", ax=axs[i])\n    axs[i].set_ylabel(col)\n</code></pre> <p></p>"},{"location":"tutorials/tutorial_develop/#available-helpers","title":"Available helpers","text":"<p>Our negotiator was not so good but it exemplifies the simplest method for developing a negotiator in NegMAS. For more information refer to NegMAS Documentation. You develop your agent, as explained above, by implementing the <code>__call__</code> method of your class.</p> <p>This method, receives an SAOState which represents the current <code>state</code> of the negotiation. The most important members of this state object are <code>current_offer</code> which gives the current offer from the partner (or <code>None</code> if this is the beginning of the negotiation) and <code>relative_time</code> which gives the relative time of the negotiation ranging between <code>0</code> and <code>1</code>.</p> <p>It should return an SAOResponse represeting the agent's <code>response</code> which consists of two parts:</p> <ol> <li>A ResponseType with the following allowed values:<ul> <li><code>ResponseType.ACCEPT_OFFER</code>, accepts the current offer (pass the current offer as the second member of the response).</li> <li><code>ResponseType.REJECT_OFFER</code>, rejects the current offer (pass you counter-offer as the second member of the response).</li> <li><code>ResponseType.END_NEGOTIATION</code>, ends the negotiation immediately (pass <code>None</code> as the second member of the response).</li> </ul> </li> <li>A counter offer (in case of rejection), the received offer (in case of acceptance) or <code>None</code> if ending the negotiation.</li> </ol> <p>The negotiator can use the following objects to help it implement its strategy:</p> <ul> <li><code>self.nmi</code> A SAONMI that gives you access to all the settings of this negotiation and provide some simple helpers:<ul> <li><code>n_steps</code>, <code>time_limit</code> The number of rounds and seconds allowed for this negotiation (<code>None</code> means no limit).</li> <li><code>random_outcomes(n)</code> Samples <code>n</code> random outcomes from this negotiation.</li> <li><code>outcome_space</code> The OutcomeSpace of the negotiation which represent all possible agreements. In ANL 2024, this will always be of type DiscreteCartesianOutcomeSpace with a single issue.</li> <li><code>discrete_outcomes()</code> A generator of all outcomes in the outcome space.</li> <li><code>log_info()</code> Logs structured information for this negotiator that can be checked in the logs later (Similarily there are <code>log_error</code>, <code>log_warning</code>, <code>log_debug</code>).</li> </ul> </li> <li><code>self.ufun</code> A LinearAdditiveUtilityFunction representing the agent's own utility function. This object provides some helpful functionality including:</li> <li><code>self.ufun.is_better(a, b)</code> Tests if outcome <code>a</code> is better than <code>b</code> (use <code>None</code> for disagreement). Similarily we have, <code>is_worse</code>, <code>is_not_worse</code> and <code>is_not_better</code>.</li> <li><code>self.ufun.reserved_value</code> Your negotiator's reserved/reservation value (between 0 and 1). You can access this also as <code>self.ufun(None)</code>.</li> <li><code>self.ufun(w)</code> Returns the utility value of the outcome <code>w</code>. It is recommended to cast this value to float (i.e. <code>float(self.ufun(w)</code>) to support probabilistic utility functions.</li> <li><code>self.outcome_space</code> The OutcomeSpace of the negotiation which represent all possible agreements. In ANL 2024, this will always be of type DiscreteCartesianOutcomeSpace with a single issue.</li> <li><code>self.ufun.invert()</code> Returns and caches an InverseUtilityFunction object which can be used to find outcomes given their utilities. The most important services provided by the InverseUtilityFunction returned are:<ul> <li><code>minmax()</code> returns the minimum and maximum values of the ufun (will always be (0, 1) approximately in ANL 2024).</li> <li><code>best()</code>, <code>worst()</code> returns the best (worst) outcomes.</li> <li><code>one_in()</code>, <code>some_in()</code> returns one (or some) outcomes within the given range of utilities.</li> <li><code>next_better()</code>, <code>next_worse()</code> returns the next outcome descendingly (ascendingly) in utility value.</li> </ul> </li> <li><code>self.opponent_ufun</code> A LinearAdditiveUtilityFunction representing the opponent's utility function. You can access this also as <code>self.private_info[\"opponent_ufun\"]</code>. This utility function will have a zero reserved value independent of the opponent's true reserved value. You can actually set the reserved value on this object to your best estimate. All ufun funcationality is available in this object.</li> </ul> <p>Other than these objects, your negotiator can access any of the analytic facilities available in NegMAS. For example, you can calculate the pareto_frontier, Nash Bargaining Soluion, Kalai Bargaining Solution, points with maximum wellfare, etc. You can check the implementation of the NashSeeker agent for examples of using these facilities.</p> <p>Other than implementing the <code>__call__</code>, method you can optionally implement one or more of the following callbacks to initialize your agent:</p> <ul> <li><code>on_negotiation_start(state: SAOState)</code> This callback is called once per negotiation after the ufuns are set but before any offers are exchanged.</li> <li><code>on_preferences_changed(changes)</code> This callback is called whenever your negotiator's ufun is changed. This will happen at the beginning of each negotiation but it can also happen again if the ufun is changed while the negotiation is running. In ANL 2024, ufuns never change during the negotiation so this callback is equivalent to <code>on_negotiation_start()</code> but for future proofness, you should use this callback for any initialization instead to guarantee that this initialization will be re-run in cases of changing utility function.</li> </ul>"},{"location":"tutorials/tutorial_develop/#understanding-our-negotiator","title":"Understanding our negotiator","text":"<p>Now we can analyze the simple random negotiator we developed earlier.</p> <ul> <li>Firstly, we find the current offer that we need to respond to:   <pre><code>offer = state.current_offer\n</code></pre></li> <li>Acceptance Strategy We then accept this offer if three conditions are satisfied:</li> <li>The offer is not <code>None</code> which means that we are not starting the negotiation just now:</li> <li>The offer is not worse than disagreement. This prevents us from accepting irrational outcomes.</li> <li>A random number we generated is less than 0.25. This means we accept rational offers with probability 25%.     <pre><code>if offer is not None and self.ufun.is_not_worse(offer, None) and random.random() &lt; 0.25:\n    return SAOResponse(ResponseType.ACCEPT_OFFER, offer)\n</code></pre></li> <li>Offering Strategy If we decided not to accept the offer, we simply generate a single random outcome and offer it:   <pre><code>return SAOResponse(ResponseType.REJECT_OFFER, self.nmi.random_outcomes(1)[0])\n</code></pre></li> </ul> <p>This negotiator did not use the fact that we know the opponent utility function up to reserved value. It did not even use the fact that we know our own utility function. As expected, it did not get a good score. Let's develop a simple yet more meaningful agent that uses both of these pieces of information.</p> <p>Can you now see why is this negotiator is getting negative advantages sometimes? We were careful in our acceptance strategy but not in our offering strategy. There is nothing in our code that prevents our negotiator from offering irrational outcomes (i.e. outcomes worse than disagreement for itself) and sometimes the opponent will just accept those. Can you fix this?</p>"},{"location":"tutorials/tutorial_develop/#a-more-meaningful-negotiator","title":"A more meaningful negotiator","text":"<p>How can we use knowledge of our own and our opponent's utility functions (up to reserved value for them)? Here is one possibility:</p> <ul> <li>Acceptance Strategy We accept offers that have a utility above some aspiration level. This aspiration level starts very high (1.0) and goes monotoncially down but never under the reserved value which is reached when the relative time is 1.0 (i.e. by the end of the negotiation). This is implemented in <code>is_acceptable()</code> below.</li> <li> <p>Opponent Modeling We estimate the opponent reserved value under the assumption that they are using a monotonically decreasing curve to select a utility value and offer an outcome around it. This is implemented in <code>update_reserved_value()</code> below.</p> </li> <li> <p>Bidding Strategy Once we have an estimate of their reserved value, we can then find out all outcomes that are rational for both we and them. We can then check the relative time of the negotiation and offer outcomes by conceding over this list of rational outcomes. This is implemented in the <code>generate_offer()</code> method below.</p> </li> </ul> <pre><code>from scipy.optimize import curve_fit\n\ndef aspiration_function(t, mx, rv, e):\n    \"\"\"A monotonically decreasing curve starting at mx (t=0) and ending at rv (t=1)\"\"\"\n    return (mx - rv) * (1.0 - np.power(t, e)) + rv\n\n\nclass SimpleRVFitter(SAONegotiator):\n    \"\"\"A simple curve fitting modeling agent\"\"\"\n    def __init__(self, *args, e: float = 5.0, **kwargs):\n        \"\"\"Initialization\"\"\"\n        super().__init__(*args, **kwargs)\n        self.e = e\n        # keeps track of times at which the opponent offers\n        self.opponent_times: list[float] = []\n        # keeps track of opponent utilities of its offers\n        self.opponent_utilities: list[float] = []\n        # keeps track of our last estimate of the opponent reserved value\n        self._past_oppnent_rv = 0.0\n        # keeps track of the rational outcome set given our estimate of the\n        # opponent reserved value and our knowledge of ours\n        self._rational: list[tuple[float, float, Outcome]] = []\n\n    def __call__(self, state):\n        # update the opponent reserved value in self.opponent_ufun\n        self.update_reserved_value(state.current_offer, state.relative_time)\n        # run the acceptance strategy and if the offer received is acceptable, accept it\n        if self.is_acceptable(state.current_offer, state.relative_time):\n            return SAOResponse(ResponseType.ACCEPT_OFFER, state.current_offer)\n        # call the offering strategy\n        return SAOResponse(ResponseType.REJECT_OFFER, self.generate_offer(state.relative_time))\n\n    def generate_offer(self, relative_time) -&gt; Outcome:\n        # The offering strategy\n        # We only update our estimate of the rational list of outcomes if it is not set or\n        # there is a change in estimated reserved value\n        if (\n            not self._rational\n            or abs(self.opponent_ufun.reserved_value - self._past_oppnent_rv) &gt; 1e-3\n        ):\n            # The rational set of outcomes sorted dependingly according to our utility function\n            # and the opponent utility function (in that order).\n            self._rational = sorted(\n                [\n                    (my_util, opp_util, _)\n                    for _ in self.nmi.outcome_space.enumerate_or_sample(\n                        levels=10, max_cardinality=100_000\n                    )\n                    if (my_util := float(self.ufun(_))) &gt; self.ufun.reserved_value\n                    and (opp_util := float(self.opponent_ufun(_)))\n                    &gt; self.opponent_ufun.reserved_value\n                ],\n            )\n        # If there are no rational outcomes (e.g. our estimate of the opponent rv is very wrong),\n        # then just revert to offering our top offer\n        if not self._rational:\n            return self.ufun.best()\n        # find our aspiration level (value between 0 and 1) the higher the higher utility we require\n        asp = aspiration_function(relative_time, 1.0, 0.0, self.e)\n        # find the index of the rational outcome at the aspiration level (in the rational set of outcomes)\n        max_rational = len(self._rational) - 1\n        indx = max(0, min(max_rational, int(asp * max_rational)))\n        outcome = self._rational[indx][-1]\n        return outcome\n\n    def is_acceptable(self, offer, relative_time) -&gt; bool:\n        \"\"\"The acceptance strategy\"\"\"\n        # If there is no offer, there is nothing to accept\n        if offer is None:\n            return False\n        # Find the current aspiration level\n        asp = aspiration_function(\n            relative_time, 1.0, self.ufun.reserved_value, self.e\n        )\n        # accept if the utility of the received offer is higher than\n        # the current aspiration\n        return float(self.ufun(offer)) &gt;= asp\n\n    def update_reserved_value(self, offer, relative_time):\n        \"\"\"Learns the reserved value of the partner\"\"\"\n        if offer is None:\n            return\n        # save to the list of utilities received from the opponent and their times\n        self.opponent_utilities.append(float(self.opponent_ufun(offer)))\n        self.opponent_times.append(relative_time)\n        # Use curve fitting to estimate the opponent reserved value\n        # We assume the following:\n        # - The opponent is using a concession strategy with an exponent between 0.2, 5.0\n        # - The opponent never offers outcomes lower than their reserved value which means\n        #   that their rv must be no higher than the worst outcome they offered for themselves.\n        bounds = ((0.2, 0.0), (5.0, min(self.opponent_utilities)))\n        try:\n            optimal_vals, _ = curve_fit(\n                lambda x, e, rv: aspiration_function(\n                    x, self.opponent_utilities[0], rv, e\n                ),\n                self.opponent_times,\n                self.opponent_utilities,\n                bounds=bounds,\n            )\n            self._past_oppnent_rv = self.opponent_ufun.reserved_value\n            self.opponent_ufun.reserved_value = optimal_vals[1]\n        except Exception as e:\n            pass\n</code></pre> <pre><code>anl2024_tournament(\n    n_scenarios=1, n_repetitions=3, nologs=True, njobs=-1,\n    competitors=[MyRandomNegotiator, SimpleRVFitter, Boulware, Conceder]\n).final_scores\n</code></pre> <pre>Will run 48 negotiations on 1 scenarios between 4 competitors\n</pre> <pre><code>Output()\n</code></pre> <pre></pre> <pre>\n</pre> <pre>             strategy     score\n0            Boulware  0.648516\n1      SimpleRVFitter  0.562182\n2            Conceder  0.314239\n3  MyRandomNegotiator  0.040486\n</pre> strategy score 0 Boulware 0.648516 1 SimpleRVFitter 0.562182 2 Conceder 0.314239 3 MyRandomNegotiator 0.040486 <p>Much better :-)</p> <p>Let's see how each part of this negotiator works and how they fit together.</p>"},{"location":"tutorials/tutorial_develop/#construction","title":"Construction","text":"<p>The first method of the negotiator to be called is the <code>__init__</code> method which is called when the negotiator is created usually before the ufun is set. You can use this method to construct the negotiator setting initial values for any variables you need to run your agent.</p> <p>An important thing to note here is that your negotiator must pass any parameters it does not use to its parent to make sure the object is constructed correctly. This is how we implement this in our <code>SimpleRVFitter</code>:</p> <pre><code>def __init__(self, *args, e: float = 5.0, **kwargs):\n    super().__init__(*args, **kwargs)\n</code></pre> <p>We then set the variables we need for our negotiator:</p> <ul> <li><code>self.e</code> stores the exponent of the concession curve we will be use (more on that later).</li> <li><code>self.opponent_times</code>, <code>self.opponent_utilities</code> keep track of the times the opponent offers and its own utility of its offers. We will use that to estimate the opponent's reserved value using simple curve fitting in <code>update_reserved_values()</code>.</li> <li><code>self._past_oppnent_rv = 0.0</code> We start assuming that the opponent has zero reserved value. This is an optimistic assumption because it means that anything rational for us is rational for the opponent so we have more negotiation power.</li> <li><code>self._rational</code> This is where we will store the list of rational outcomes to concede over. For each outcome we will store our utility, opponent utility and the outcome itself (in that order).</li> </ul>"},{"location":"tutorials/tutorial_develop/#overall-algorithm","title":"Overall Algorithm","text":"<p>The overall algorithm is implemented --- as usual --- in the <code>__call__()</code> method. This is the complete algorithm:</p> <pre><code>def __call__(self, state):\n    self.update_reserved_value(state.current_offer, state.relative_time)\n    if self.is_acceptable(state.current_offer, state.relative_time):\n        return SAOResponse(ResponseType.ACCEPT_OFFER, state.current_offer)\n    return SAOResponse(ResponseType.REJECT_OFFER, self.generate_offer(state.relative_time))\n</code></pre> <p>We start by updating our estimate of the reserved value of the opponent using <code>update_reserved_value()</code>. We then call the acceptance strategy <code>is_acceptable()</code> to check whether the current offer should be accepted. If the current offer is not acceptable, we call the bidding strategy <code>generate_offer()</code> to generate a new offer which we return as our counter-offer. Simple!!</p>"},{"location":"tutorials/tutorial_develop/#opponent-modeling-estimating-reserved-value","title":"Opponent Modeling (Estimating Reserved Value)","text":"<p>The first step is in our algorithm is to update our estimate of the opponent's reserved value. This is done in three simple steps:</p> <ol> <li>If we have not offer from the opponent, there is nothing to do. Just return:    <pre><code>if offer is None:\n     return\n</code></pre></li> <li>We append the time and opponent's utility to our running list of opponent offer utilities:    <pre><code>self.opponent_utilities.append(float(self.opponent_ufun(offer)))\nself.opponent_times.append(relative_time)\n</code></pre></li> <li> <p>We apply a simple curve fitting algorithm from scipy to estimate the opponent's reserved value (and its concession exponent but we are not going to use that):</p> <ul> <li>We set the bounds of the reserved value to be between zero (minimum possible value) and the minimum utility the opponent ever offered. This assumes that the opponent only offers rational outcomes for itself. The bounds for the concession curve are set to (0.2, 5.0) which is the usual range of exponents used by time-based strategies.   <pre><code>bounds = ((0.2, 0.0), (5.0, min(self.opponent_utilities)))\n</code></pre></li> <li>We then just apply curve fitting while keeping the old estimate. We keep the old estimate to check whether there is enough change to warrent reevaluation of the rational outcome sets in our offering strategy. We ignore any errors keeping the old estimate in that case.</li> </ul> <p><pre><code>optimal_vals, _ = curve_fit(\n    lambda x, e, rv: aspiration_function(x, self.opponent_utilities[0], rv, e),\n    self.opponent_times, self.opponent_utilities, bounds=bounds\n)\n</code></pre>   Note that we just pass <code>self.opponent_utilities[0]</code> as the maximum for the concession curve because we know that this is the utility of the first offer from the opponent.</p> <ul> <li>Finally, we update the opponent reserved value with our new estimate keeping the latest value for later:   <pre><code>self._past_oppnent_rv = self.opponent_ufun.reserved_value\nself.opponent_ufun.reserved_value = optimal_vals[1]\n</code></pre></li> </ul> </li> </ol>"},{"location":"tutorials/tutorial_develop/#acceptance-strategy","title":"Acceptance Strategy","text":"<p>Our acceptance strategy is implemented in <code>is_acceptable()</code> and consists of the following steps:</p> <ol> <li>Reject if no offer is found (i.e. we are starting the negotiation now):    <pre><code>if offer is None:\n    return False\n</code></pre></li> <li>Find our current aspiration level which starts at 1.0 (inidicating we will only accept our best offer in the first step) ending at our reserved value (indicating that we are willing to accept any rational outcome by the end of the negotiation). Use the exponent we stored during construction.    <pre><code>asp = aspiration_function(state.relative_time, 1.0, self.ufun.reserved_value, self.e)\n</code></pre></li> <li>Accept the offer iff its utility is higher than the aspiration level:     <pre><code>return float(self.ufun(offer)) &gt;= asp\n</code></pre> Note that this acceptance strategy does not use the estimated opponent reserved value (or the opponent's ufun) in any way.</li> </ol>"},{"location":"tutorials/tutorial_develop/#bidding-strategy","title":"Bidding Strategy","text":"<p>Now that we have updated our estimate of the opponent reserved value and decided not to accept their offer, we have to generate our own offer which the job of the bidding strategy implementedin <code>generate_offer()</code>. This is done in three steps as well:</p> <ol> <li> <p>If the difference between the current and last estimate of the opponent reserved value is large enough, we create the rational outcome list.</p> <ul> <li>This test is implemented by: <pre><code>not self._rational or abs(self.opponent_ufun.reserved_value - self._past_oppnent_rv) &gt; 1e-3\n</code></pre></li> <li>We then create of all outcomes prepending them with our and opponent's utility values:   <pre><code>[ (my_util, opp_util, _)\n  for _ in self.nmi.outcome_space.enumerate_or_sample(\n      levels=10, max_cardinality=100_000\n  )\n  if (\n      (my_util := float(self.ufun(_))) &gt; self.ufun.reserved_value\n      and (opp_util := float(self.opponent_ufun(_))) &gt; self.opponent_ufun.reserved_value\n)]\n</code></pre></li> <li>Finally, we sort this list. Because each element is a tuple, the list will be sorted ascendingly by our utility with equal values sorted ascendingly by the opponent utility.   <pre><code>self._rational = sorted(...)\n</code></pre></li> </ul> </li> <li> <p>If there are no rational outcomes (e.g. our estimate of the opponent rv is very wrong), then just revert to offering our top offer    <pre><code>if not self._rational:\n     return self.ufun.best()\n</code></pre></p> </li> <li>If we have a rational set, we calculate an aspiration level that starts at 1 and ends at 0 (note that we do not need to end at the reserved value because all outcomes in <code>self._rational</code> are already no worse than disagreement. We then calculate the outcome that is at the current aspiration level from the end of the rational outcome list and offer it:    <pre><code>asp = aspiration_function(relative_time, 1.0, 0.0, self.e)\nmax_rational = len(self._rational) - 1\nindx = max(0, min(max_rational, int(asp * max_rational)))\noutcome = self._rational[indx][-1]\nreturn outcome\n</code></pre></li> </ol>"},{"location":"tutorials/tutorial_develop/#running-a-single-negotiation","title":"Running a single negotiation","text":"<p>What if we now want to see what happens in a single negotiation using our shiny new negotiator? We first need a scenario to define the outcome space and ufuns. We can then add negotiators to it and run it. Let's see an example:</p> <pre><code>import copy\nfrom negmas.sao import SAOMechanism\nfrom anl.anl2024.runner import mixed_scenarios\nfrom anl.anl2024.negotiators.builtins import Linear\n\n# create a scenario\ns = mixed_scenarios(1)[0]\n# copy ufuns and set rv to 0 in the copies\nufuns0 = [copy.deepcopy(u) for u in s.ufuns]\nfor u in ufuns0:\n    u.reserved_value = 0.0\n# create the negotiation mechanism\nsession = SAOMechanism(n_steps=1000, outcome_space=s.outcome_space)\n# add negotiators. Remember to pass the opponent_ufun in private_info\nsession.add(\n    SimpleRVFitter(name=\"SimpleRVFitter\",\n                   private_info=dict(opponent_ufun=ufuns0[1]))\n    , ufun=s.ufuns[0]\n)\nsession.add(Linear(name=\"Linear\"), ufun=s.ufuns[1])\n# run the negotiation and plot the results\nsession.run()\nsession.plot()\nplt.show()\n</code></pre> <p></p> <p>Notice how in the second half of the negotiation, the SimpleRVFitter is only offering outcomes that are rational for both negotiators (can you see that in the left-side plot? can you see it in the top right-side plot?). This means that the curve fitting approach is working OK here. The opponent is a time-based strategy in this case though.</p> <p>What happens if it was not? Let's try it against the builtin RVFitter for example</p> <pre><code>from anl.anl2024.negotiators import RVFitter\n# create the negotiation mechanism\nsession = SAOMechanism(n_steps=1000, outcome_space=s.outcome_space)\n# add negotiators. Remember to pass the opponent_ufun in private_info\nsession.add(\n    SimpleRVFitter(name=\"SimpleRVFitter\",\n                   private_info=dict(opponent_ufun=ufuns0[1]))\n    , ufun=s.ufuns[0]\n)\nsession.add(\n    RVFitter(name=\"RVFitter\",\n                   private_info=dict(opponent_ufun=ufuns0[0]))\n    , ufun=s.ufuns[1]\n)\n\n# run the negotiation and plot the results\nsession.run()\nsession.plot()\nplt.show()\n</code></pre> <p></p> <p>This time, our simple RV fitter could not really learn the opponent reserved value effectively. We can see that from the fact that it kept offering outcomes that are irrational for the opponent almost until the end of the negotiation.</p> <p>The builtin <code>RVFitter</code> seems better in this case. It took longer but it seems to only offer rational outcomes for its opponent (our SimpleRVFitter) after around 60% of the available negotiation time.</p>"},{"location":"tutorials/tutorial_develop/#other-examples","title":"Other Examples","text":"<p>The ANL package comes with some example negotiators. These are not designed to be stong but to showcase how to use some of the features provided by the platform.</p> <ul> <li>MiCRO A strong baseline behavioral negotiation strategy developed by de Jonge, Dave in \"An Analysis of the Linear Bilateral ANAC Domains Using the MiCRO Benchmark Strategy.\", ICJAI 2022. This strategy assumes no knowledge of the opponent utility function and is implemented from scratch to showcase the following:<ul> <li>Using <code>on_preferences_changed</code> for initialization.</li> <li>Using PresortingInverseUtilityFunction for inverting a utility function.</li> </ul> </li> <li>NashSeeker A naive strategy that simply sets the opponent reserved value to a fixed value and then uses helpers from NegMAS to find the Nash Bargaining Solution and use it for deciding what to offer. This showcases:<ul> <li>Using NegMAS helpers to calculate the pareto-frontier and the Nash Bargaining Solution</li> </ul> </li> <li>RVFitter A strategy very similar to the one we implemented earlier as <code>SimpleRVFitter</code>. Instead of trying to estiamte the opponent reserved value from the first step, this strategy waits until it collects few offers before attempting the etimation. This showcases:<ul> <li>Setting the opponent reserved value based on our best estimate.</li> <li>A simple way to use this estimate for our bidding strategy.</li> <li>Using logging. Logs can be saved using <code>self.nmi.log_info(dict(my_key=my_value))</code> and found under the logs folder.</li> </ul> </li> <li>Boulware, Conceder, Linear Time-based strategies that are implemented by just setting construction parameters of an existing NegMAS negotiator</li> <li>StochasticBoulware, StochasticConceder, StochasticLinear Stochastic versions of the three time-based strategies above implemented by just setting construction parameters of an existing NegMAS negotiator</li> <li>NaiveTitForTat A simple behavioral strategy implemented by just inheriting from an existing NegMAS negotiator.</li> </ul>"},{"location":"tutorials/tutorial_develop/#note-about-running-tournaments","title":"Note about running tournaments","text":"<ul> <li>When running a tournament using <code>anl2024_tournament</code> inside a Jupyter Notebook, you must pass <code>njobs=-1</code> to force serial execution of negotiations. This is required because the multiprocessing library used by NegMAS does not play nicely with Jupyter Notebooks. If you run the tournament using the same method from a <code>.py</code> python script file, you can omit this argument to run a tournament using all available cores.</li> <li>When you pass <code>nologs=True</code>, no logs are stored for this tournament. If you omit this argument, a log will be created under <code>~/negmas/anl2024/tournaments</code> which can be visualized using the ANL visualizer by running:</li> </ul> <pre><code>anlv show\n</code></pre> <p>Download Notebook</p>"},{"location":"tutorials/tutorial_scenarios/","title":"Visualizing preference profiles","text":"<p>In ANL 2024, different types of scenarios are used, see the detailed description of ANL 2024 for more information. In this notebook, we will provide some code to visualize the different types.</p> <pre><code>from negmas import SAOMechanism\nfrom anl.anl2024 import zerosum_pie_scenarios, monotonic_pie_scenarios, arbitrary_pie_scenarios\n\nscenario = monotonic_pie_scenarios(n_scenarios=2, n_outcomes=20)[0] #zerosum_pie_scenarios, arbitrary_pie_scenarios\nsession = SAOMechanism(issues=scenario.issues, n_steps=30)\nA_utility = scenario.ufuns[0]\nB_utility = scenario.ufuns[1]\n#visualize((session, A_utility, B_utility))\n</code></pre> <p>In the first line, we generate a <code>monotonic_pie_scenario</code> (or actually 2), which is one of three types of scenarios. The other two are  <code>zerosum_pie_scenarios</code> and <code>arbitrary_pie_scenarios</code>. After extracting the corresponding utility functions, we can visualize the session in the same way we did in the previous notebook (running a negotiation).</p> <p>For completeness, we provide the code for the <code>visualize</code> function below. By removing the <code>session.run</code> statement, it is possible to see the scenario plotted, without a negotiation taking place. This is useful to see the shape of the scenario, and to understand the preferences of the agents.</p> <pre><code>from anl.anl2024.negotiators import Conceder, Boulware\n\ndef visualize(negotiation_setup):\n    (session, A_utility, B_utility) = negotiation_setup\n\n    # create and add selller and buyer to the session\n    AgentA = Boulware(name=\"A\")\n    AgentB = Boulware(name=\"B\")\n    session.add(AgentA, ufun=A_utility)\n    session.add(AgentB, ufun=B_utility)\n\n    # run the negotiation and show the results\n    # session.run()\n\n    session.plot(ylimits=(0.0, 1.01), show_reserved=True)\n    plt.show()\n\nvisualize((session, A_utility, B_utility))\n</code></pre> <p></p> <p>Download Notebook</p>"}]}